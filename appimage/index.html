

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>AppImage documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home" alt="Documentation Home"> AppImage
          

          
          </a>

          
            
            
          

          

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-introduction/index">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-introduction/quickstart">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-introduction/motivation">Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-introduction/advantages">AppImage advantages</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-introduction/concepts">Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-introduction/software-overview">Software Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-introduction/upstream">A word on upstream packaging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user-guide/index">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-user-guide/faq">Frequently Asked Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-user-guide/run-appimages">Running AppImages</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-user-guide/portable-mode">Using portable mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-user-guide/mac">AppImage for macOS switchers</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-user-guide/troubleshooting">Troubleshooting</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-packaging-guide/index">Packaging Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/introduction">Introduction to Packaging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/from-source/index">Packaging from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/converting-binary-packages/index">Converting binary packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/optional/index">Optional Resources and Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/hosted-services/index">Hosted services</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/manual">Manual packaging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/testing">Testing your AppImage</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/distribution">Distributing AppImages</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-packaging-guide/environment-variables">Environment variables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-reference/index">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-reference/architecture">Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-reference/specification">AppImage specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-reference/best-practices">Best practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-reference/appdir">AppDir specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-reference/desktop-integration">Desktop integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-contact">Contact</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#irc">IRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#forum">Forum</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">AppImage</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>AppImage  documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/AppImage/docs.appimage.org/blob/master/source/index" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <a class="reference internal image-reference" href="_images/appimage.svg"><img alt="_images/appimage.svg" class="align-center" src="_images/appimage.svg" width="300px" /></a>
<hr class="docutils" />
<div class="section" id="welcome-to-the-appimage-documentation">
<span id="home"></span><h1>Welcome to the AppImage documentation<a class="headerlink" href="#welcome-to-the-appimage-documentation" title="Permalink to this headline">¶</a></h1>
<p class="centered">
<strong>Willkommen • Welcome • 欢迎 • Bienvenue • Benvenuto • Bienvenido • ようこそ • Mabuhay • Välkommen • أهلا وسهلا • Добро пожаловать • Merhaba • Bonvenon • 歡迎光臨</strong></p><hr class="docutils" />
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p class="centered">
<strong><strong>First-time users, heads up!</strong> Check out our <a class="reference internal" href="index.html#ref-quickstart"><span class="std std-ref">Quickstart</span></a> chapter!</strong></p></div>
<p>In this documentation, all aspects of the AppImage project shall be explained, to have a single unified source of information.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p class="centered">
<strong><strong>This documentation contains a lot of valuable information, but there’s always something to add.</strong> <a class="reference external" href="https://github.com/AppImage/docs.appimage.org">Contributions welcome!</a></strong></p></div>
<p>If you are new to AppImage, please read the introduction. It describes the ideas behind AppImage, shows the motivation, explains why you as a user and/or developer should be interested in AppImages. Also, it explains the core concepts of AppImage’s design.</p>
<p>To learn more about <em>using</em> AppImages, please read the User Guide. If you are interested in building and distributing AppImages or building software that works with AppImages, please check the Packaging Guide.</p>
<div class="toctree-wrapper compound">
<span id="document-introduction/index"></span><div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>AppImage provides a way for upstream developers to provide “native” binaries for Linux users just the same way they could do for other operating systems. It allow packaging applications for any common Linux based operating system, e.g., Ubuntu, Debian, openSUSE, RHEL, CentOS, Fedora etc. AppImages come with all dependencies that cannot be assumed to be part of each target system in a recent enough version and will run on most Linux distributions without further modifications.</p>
<p>AppImage is the format, and <a class="reference external" href="https://github.com/AppImage/AppImageKit">AppImageKit</a> provides a reference implementation.</p>
<p>The following section provides an overview of the AppImage idea, the motives behind AppImage, and explains the basic concepts. Furthermore, there’s an overview over the currently existing software, and some words on upstream packaging.</p>
<div class="toctree-wrapper compound">
<span id="document-introduction/quickstart"></span><div class="section" id="quickstart">
<span id="ref-quickstart"></span><h3>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h3>
<p>This page contains information for users new to AppImage, and want to get started.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#how-to-run-an-appimage" id="id1">How to run an AppImage</a></p></li>
<li><p><a class="reference internal" href="#getting-help" id="id2">Getting help</a></p></li>
</ul>
</div>
<div class="section" id="how-to-run-an-appimage">
<span id="ref-how-to-run-appimage"></span><h4><a class="toc-backref" href="#id1">How to run an AppImage</a><a class="headerlink" href="#how-to-run-an-appimage" title="Permalink to this headline">¶</a></h4>
<p>It’s quite simple to run AppImages. All you have to do is download them, make them executable and run them. This can either be done using the GUI or via the command line.</p>
<div class="section" id="using-the-gui">
<h5>Using the GUI<a class="headerlink" href="#using-the-gui" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>Open your file manager and browse to the location of the AppImage</p></li>
<li><p>Right-click on the AppImage and click the ‘Properties’ entry</p></li>
<li><p>Switch to the Permissions tab and</p></li>
<li><p>Click the ‘Allow executing file as program’ checkbox if you are using a Nautilus-based file manager (Files, Nemo, Caja), or click the ‘Is executable’ checkbox if you are using Dolphin, or change the ‘Execute’ drop down list to ‘Anyone’ if you are using PCManFM</p></li>
<li><p>Close the dialog</p></li>
<li><p>Double-click on the AppImage file to run</p></li>
</ol>
<p>Please see also the video below:</p>
<img alt="_images/make-executable.gif" src="_images/make-executable.gif" />
</div>
<div class="section" id="using-the-terminal">
<h5>Using the Terminal<a class="headerlink" href="#using-the-terminal" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>Open a terminal</p></li>
<li><p>Change to the directory containing the AppImage, e.g., using <code class="code docutils literal notranslate"><span class="pre">cd</span> <span class="pre">&lt;my</span> <span class="pre">directory&gt;</span></code></p></li>
<li><p>Make the AppImage executable: <code class="code docutils literal notranslate"><span class="pre">chmod</span> <span class="pre">+x</span> <span class="pre">my.AppImage</span></code></p></li>
<li><p>Run the AppImage: <code class="code docutils literal notranslate"><span class="pre">./my.AppImage</span></code></p></li>
</ol>
<p>That’s it! The AppImage should now be executed.</p>
</div>
<div class="section" id="translated-versions-of-this-guide">
<h5>Translated versions of this guide<a class="headerlink" href="#translated-versions-of-this-guide" title="Permalink to this headline">¶</a></h5>
<p>Translated versions are available in a <a class="reference external" href="https://discourse.appimage.org/t/how-to-run-an-appimage/80">post in the AppImage forum</a>.</p>
</div>
</div>
<div class="section" id="getting-help">
<h4><a class="toc-backref" href="#id2">Getting help</a><a class="headerlink" href="#getting-help" title="Permalink to this headline">¶</a></h4>
<p>If you’re new to AppImage and have problems getting up and running, please don’t hesitate to contact the AppImage team and their awesome community. They’re happy to help! Please see the <a class="reference internal" href="index.html#ref-contact"><span class="std std-ref">Contact page</span></a> for more information.</p>
</div>
</div>
<span id="document-introduction/motivation"></span><div class="section" id="motivation">
<h3>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h3>
<p>There’s two different points of view when looking at AppImages: the user’s and the developer’s. The following section explains both of them.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#why-would-i-as-a-user-want-to-use-appimages" id="id1">Why would I as a user want to use AppImages?</a></p></li>
<li><p><a class="reference internal" href="#why-would-i-as-a-developer-want-to-make-and-distribute-appimages" id="id2">Why would I as a developer want to make and distribute AppImages?</a></p></li>
</ul>
</div>
<div class="section" id="why-would-i-as-a-user-want-to-use-appimages">
<h4><a class="toc-backref" href="#id1">Why would I as a user want to use AppImages?</a><a class="headerlink" href="#why-would-i-as-a-user-want-to-use-appimages" title="Permalink to this headline">¶</a></h4>
<p>Consider the following user stories:</p>
<blockquote>
<div><p>“I as a user want to run the latest version of my favorite app on my stable distribution, which ships only with an old outdated version.”</p>
<p>“I as a user need to use multiple versions of an application in parallel.”</p>
<p>“I as a user want to take my favorite applications with me on a portable disk together with my data, allowing me to use any Linux computer to work with my files.”</p>
<p>“I am in a corporate or university environment and want to simply run some specific software, but lack permissions to ‘install’ applications.”</p>
</div></blockquote>
<p>All these use cases can be accomplished by using AppImages. They’re a trade-off between a simple user experience and resulting file size. The unique user experience guarantees that even less tech-savvy people can get started without any major issues. AppImage is primarily a user-focused way of bundling software.</p>
<p>As AppImage has been around for a while, a lot of useful, optional features have been developed, ranging from <a class="reference internal" href="index.html#ref-appimageupdate"><span class="std std-ref">efficient updates</span></a> over so-called <a class="reference internal" href="index.html#ref-desktop-integration"><span class="std std-ref">desktop integration</span></a> to <a class="reference internal" href="index.html#ref-appimagehub"><span class="std std-ref">software catalogs</span></a>. None of these are required for the basic experience, though. AppImages are designed to <a class="reference internal" href="index.html#ref-download-make-executable-run"><span class="std std-ref">be run in three steps at most</span></a>.</p>
<p>An important advantage is that AppImage is designed from ground to run without super user permissions. Almost all major distributions are compatible with AppImages, without requiring the user to make modifications to the base system. AppImages ship with their own runtime, and don’t require external resources if packaged properly. Students in university labs for instance can simply put an AppImage on a USB disk and use it normally, on any machine.</p>
<p>To sum up: AppImages provide a easy and unified user experience, have a large user base and eco system, and there’s a lot of tools that improve the users’ user experience.</p>
</div>
<div class="section" id="why-would-i-as-a-developer-want-to-make-and-distribute-appimages">
<h4><a class="toc-backref" href="#id2">Why would I as a developer want to make and distribute AppImages?</a><a class="headerlink" href="#why-would-i-as-a-developer-want-to-make-and-distribute-appimages" title="Permalink to this headline">¶</a></h4>
<p>Many developers have found that they can deploy their apps to most operating systems with viable efforts. They can say, “I make binaries for Windows”, or “I make binaries for macOS”. However, when trying to do the same for Linux, they commonly face a situation where they cannot “make binaries for Linux”, but they have to make them for Ubuntu, Debian, CentOS, openSUSE etc. Read: they have to make binaries for every distribution.</p>
<p>The problem with this is that Linux is just the kernel, but the operating systems users run are separate projects with separate goals and concerns. They all ship with different versions and combinations of certain libraries, and most of them require software to be shipped separately, linking to binaries in the distribution. Therefore, in order to be able to run a certain binary, that binary must be compiled <em>against</em> the distribution’s set of libraries. As soon as another distribution’s collection of libraries is not the same as the one the binary was built on, it will crash or even refuse to run.</p>
<p>To fix this issue, one has to do the same one would do to prevent issues like missing shared libraries (or version incompatibilities) that is used on other platforms: ship the dependency libraries along with the own software’s binaries.</p>
<p>This can be accomplished using traditional tarballs that contain all the libraries and maybe some sort of “run script” that makes sure only those libraries are run, but it has a few major disadvantages. First of all, it is hard to get the right set of libraries that must be shipped, excluding the ones that would cause issues (lowest level dependencies such as <code class="docutils literal notranslate"><span class="pre">libc</span></code>, <code class="docutils literal notranslate"><span class="pre">libdl</span></code>, etc.). But even worse, the user is presented with an archive that they must extract, and they must be explained how to actually run the software within it. Furthermore, they now have that data on their hard drive, and have to manage it themselves, without any kind of helpers.</p>
<p>In order to improve the usability and reduce the maintenance effort, AppImage was created. AppImages are bundles of programs, their dependency libraries and all the resources they need during the runtime. They’re single binaries, following the “<a class="reference internal" href="index.html#one-app-one-file-principle"><span class="std std-ref">one app = one file</span></a>” core principle.</p>
<p>Making AppImages is very simple for a developer. There’s tools which generate an AppImage from a so-called <span class="xref std std-ref">AppDir</span>. There’s simple tools to create such an AppDir for an existing software, which are aware of potential cross distro incompatibilities, and try to avoid them. And once the AppImage has been built, it will “just run” on all major desktop distributions.</p>
<p>Stop making binaries “for distributions” and start making binaries “for Linux” today!</p>
</div>
</div>
<span id="document-introduction/advantages"></span><div class="section" id="appimage-advantages">
<h3>AppImage advantages<a class="headerlink" href="#appimage-advantages" title="Permalink to this headline">¶</a></h3>
<p>This chapter compares AppImage with traditional application packaging formats on Linux and explains the advantages of the AppImage format. You can skip this chapter if you already know why AppImages are useful.</p>
<p>Traditionally, applications have been installed on Linux systems by using the package manager that comes with the Linux distribution. However, this model does not scale well for long-tail applications, applications that are only used by a few users, or in cases where users want to use the very latest applications immediately after they are published by their developers. It also is very cumbersome for application developers that want to reach a large audience quickly.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#advantages-for-users" id="id1">Advantages for users</a></p></li>
<li><p><a class="reference internal" href="#advantages-for-system-administrators" id="id2">Advantages for system administrators</a></p></li>
<li><p><a class="reference internal" href="#advantages-for-application-authors" id="id3">Advantages for application authors</a></p></li>
<li><p><a class="reference internal" href="#advantages-for-software-testers" id="id4">Advantages for software testers</a></p></li>
</ul>
</div>
<div class="section" id="advantages-for-users">
<h4><a class="toc-backref" href="#id1">Advantages for users</a><a class="headerlink" href="#advantages-for-users" title="Permalink to this headline">¶</a></h4>
<p>On the desktop, users are used to installing an operating system, using that operating systems for many years, and running the most recent applications whenever they feel like it. However, many Linux distributions restrict the availability of applications to those that were already published at the point in time when the Linux distribution was published. This effectively means that if the user wants to use a stable operating system, then the user is locked into a set of applications that was recent at the point when the operating system was released. While this may be reasonable for enterprise-critical applications or server side processes, it is not the model users expect from a desktop operating system.</p>
<p>So-called “rolling release” distributions exist that provide latest versions of software. However, they make no distinction between the core operating system and applications. So, with a “rolling release” distribution users don’t only get the latest applications, but also an ever-changing base system. While this may be suitable for hobbyists and technology enthusiasts, it is hardly suitable for productive use where the base system has to be supportable.</p>
<p>The combination of a long-term stable base operating system with the latest applications delivered in AppImage format can provide an elegant solution to this dilemma. While the base operating system can stay stable and only change every few years, users can download and run the very latest applications whenever they appear.</p>
<p>AppImage also makes it easy to try out new versions of applications. Since versions can exist alongside each other, the user can simply download a new version of an application and try it out. If the new version proves to be superior, the user that can then delete the old version and work with the new one. However, should the new version have bugs or be otherwise unusable, the user can simply delete the new version and continue using the old version. This is also very useful for testing nightly or continuous builds and for giving feedback to the application development team.</p>
</div>
<div class="section" id="advantages-for-system-administrators">
<h4><a class="toc-backref" href="#id2">Advantages for system administrators</a><a class="headerlink" href="#advantages-for-system-administrators" title="Permalink to this headline">¶</a></h4>
<p>System administrators in corporate, educational or institutional settings usually need to support a large number of desktop systems, where they either need to lock down the system so that users cannot make changes such as application installations, or need to find a way to leave the base system supportable while users can run applications on top.</p>
<p>AppImages provide an elegant solution here: Since the core operating system is not changed through the installation of applications, the system stays pristine and supportable no matter what kind of applications end users run on the system. Users are happy because they can run their favorite applications without having to ask a system administrator to install them. System administrators are happy because they have less work.</p>
</div>
<div class="section" id="advantages-for-application-authors">
<h4><a class="toc-backref" href="#id3">Advantages for application authors</a><a class="headerlink" href="#advantages-for-application-authors" title="Permalink to this headline">¶</a></h4>
<p>Application authors may want to reach as many users as possible, regardless of the operating system and version users are running.  With the traditional model, application authors either need to get their application into Linux distributions by creating packages according to the rules of distributions, which can be a lengthy and time-consuming process, or need to find someone who creates the application package for them. It does not help that different Linux distributions have very different rules for packaging applications. This means that if an author is successful to package an application according to the rules of one distribution, it may well not be suitable for inclusion in another distribution. In any case, it is not a quick and easy operation to get a new application into every Linux distribution. And even if an author gets an application into a Linux distribution, it will only appear in the soon-to-be-released version of that Linux distribution, which means that all the currently existing users using older versions of the Linux distribution are left out in the cold.</p>
<p>If a third party (the distribution’s “maintainer”) packages the application for inclusion in the distribution, the third party may make unintended changes to the application not authorized by the original author. This has led to some application authors to ask Linux distributions to no longer distribute their software because they did not like the changes.</p>
<p>Some developers do not want their applications to be distributed randomly, but be in full control over who downloads what and when. For example an application author may want users to fill in a survey before downloading the application. Also, the author may want to count the number of downloads.  In other cases still, the application author may want to ask for a donation or even a required payment before the user can download the application through services such as Gumroad, PayPal, or Patreon. In the traditional Linux distribution model, this is not possible.</p>
<p>Providing an AppImage solves these kinds of issues, since the application author is in full control over the application distribution and the user experience connected to it.</p>
<p>Some applications require certain versions of dependencies in order to function properly. For example, an application may run only on a certain version of the Qt framework and may run into unexpected issues if another version is used. In the traditional Linux distribution model, an application has to use whatever version of a library the Linux distribution happens to provide, whereas with AppImage, the application author can exactly decide which version of a dependency should be used by the application.</p>
</div>
<div class="section" id="advantages-for-software-testers">
<h4><a class="toc-backref" href="#id4">Advantages for software testers</a><a class="headerlink" href="#advantages-for-software-testers" title="Permalink to this headline">¶</a></h4>
<p>Successful application projects run a lot of tests. Whereas some tests may be automated, manual tests are always important to ensure both functionality and usability. In regression testing, different versions of an application are compared to each other concerning features and bugs. AppImage makes it easy to conduct application tests on local machines, since it allows to run various different versions of applications alongside each other. With portable mode, it is also possible to isolate the settings of each version of the application from each other, allowing for clean testing environments.</p>
<p>The <a class="reference external" href="https://www.libreoffice.org/download/appimage/">LibreOffice</a> project, for example, uses AppImages to test new application versions.</p>
</div>
</div>
<span id="document-introduction/concepts"></span><div class="section" id="concepts">
<h3>Concepts<a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h3>
<p>The AppImage development follows a few easy-to-understand core principles and concepts that keep it simple to use for developers and users. In this section, the most prominent concepts are explained.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#one-app-one-file" id="id3">One app = one file</a></p></li>
<li><p><a class="reference internal" href="#do-not-depend-on-system-provided-resources" id="id4">Do not depend on system-provided resources</a></p></li>
<li><p><a class="reference internal" href="#build-on-old-systems-run-on-newer-systems" id="id5">Build on old systems, run on newer systems</a></p></li>
<li><p><a class="reference internal" href="#appimage-specification" id="id6">AppImage specification</a></p></li>
<li><p><a class="reference internal" href="#appdirs" id="id7">AppDirs</a></p></li>
</ul>
</div>
<div class="section" id="one-app-one-file">
<span id="one-app-one-file-principle"></span><h4><a class="toc-backref" href="#id3">One app = one file</a><a class="headerlink" href="#one-app-one-file" title="Permalink to this headline">¶</a></h4>
<p>AppImages are simple to understand. Every AppImage is a regular file, and every AppImage contains exactly one app with all its dependencies. Once the AppImage is <a class="reference internal" href="index.html#ref-download-make-executable-run"><span class="std std-ref">made executable</span></a>, a user can just run it, either by double clicking it in their desktop environment’s file manager, by running it from the console etc.</p>
<div class="admonition note" id="ref-opinion-reusable-frameworks">
<p class="admonition-title">Note</p>
<p>On a regular basis, <a class="reference external" href="https://github.com/AppImage/AppImageKit/issues/848">users ask</a> about implementing support for some sort of “reusable/shared frameworks”. These frameworks are supposed to contain bundles of libraries which are needed by more than one AppImage, and hence could save some disk space. For management, they suggest complex automagic systems that will automatically fetch the “frameworks” from the Internet if they’re not available, or some complicated, mostly manual methods how to users could bundle frameworks together with the AppImages on portable disks like USB sticks.</p>
<p>These may be good ideas for some people, and even if they worked perfectly fine, they’d break with our most important concept: <a class="reference internal" href="#one-app-one-file-principle"><span class="std std-ref">one app = one file</span></a>. AppImages are so simple to understand <em>because</em> every application is a single file. There’s no complexity in this approach, even grandma could understand it. And after all, disk space is cheap nowadays, right?</p>
<p>If you prefer this approach or absolutely need it, please check out alternative approaches. AppImage will never implement such a feature.</p>
</div>
</div>
<div class="section" id="do-not-depend-on-system-provided-resources">
<span id="no-external-dependencies"></span><h4><a class="toc-backref" href="#id4">Do not depend on system-provided resources</a><a class="headerlink" href="#do-not-depend-on-system-provided-resources" title="Permalink to this headline">¶</a></h4>
<p>The author of an AppImage needs to decide for which target systems (Linux distributions) they want to offer the AppImage.  Then, the author needs to bundle any dependencies that cannot reasonably be assumed to come with every target system (Linux distributions) in its default installation in a recent enough version.</p>
<p>To be able to run on any Linux distribution, an AppImage should bundle all the resources it needs at runtime that cannot be reasonably expected to be “there” in the default installation of all still-supported target systems (Linux distributions). The most common resources are the actual binaries, shared library dependencies, icons and other graphics and of course one or more desktop files for desktop integration.</p>
<p>This doesn’t mean an AppImage must not use resources provided by the system, like for example basic libraries that can be assumed to be part of every target system (e.g., the C standard library or graphics libraries), user interface themes or the like. See the  <a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/master/excludelist">excludelist</a> for a list of the libraries we consider to currently be part of each still-supported target system (distribution).</p>
</div>
<div class="section" id="build-on-old-systems-run-on-newer-systems">
<span id="build-on-old-systems"></span><h4><a class="toc-backref" href="#id5">Build on old systems, run on newer systems</a><a class="headerlink" href="#build-on-old-systems-run-on-newer-systems" title="Permalink to this headline">¶</a></h4>
<p>It is considered best practice to develop and compile the application on the oldest still-supported Linux distribution that we can assume users to still use. For example, the oldest still-supported LTS release of Ubuntu is a good choice to develop applications against and build applications on.</p>
<p>Applications should be built on the oldest possible system, allowing them to run on newer system. This allows the exclusion of certain “base libraries”, which can be expected to be present on all major desktop Linux distributions, reducing the overhead of <a class="reference internal" href="#one-app-one-file-principle"><span class="std std-ref">one app = one file</span></a>. These dependencies are mostly shared libraries and involve low level libraries like <code class="code docutils literal notranslate"><span class="pre">libc.so.6</span></code> (the GNU C library, the C language standard library the majority of all Linux distributions use), but also common libraries like <a class="reference external" href="https://zlib.net/">zlib</a> or the <a class="reference external" href="https://developer.gnome.org/glib/">GLib</a> libraries are normally present.</p>
<p>It may seem contradictory to <a class="reference internal" href="#no-external-dependencies"><span class="std std-ref">the previous section</span></a> to rely on distribution provided resources. This is a trade-off between trying to reduce redundancies while at the same time being as self-contained as possible.</p>
<p>In some cases, including the libraries might even break the AppImage on the target system. Those libraries involve, among others, hardware dependent libraries such as graphics card drivers provided libraries (e.g., <code class="code docutils literal notranslate"><span class="pre">libGL.so.1</span></code>, (<a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/14c255b528dd88ef3e00ae0446ac6d84a20ac798/excludelist#L38-L41">source</a>)), or libraries that are build and linked differently on different distributions (e.g., <code class="code docutils literal notranslate"><span class="pre">libharfbuzz.so.0</span></code> and <code class="code docutils literal notranslate"><span class="pre">libfreetype.so.6</span></code> (<a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/14c255b528dd88ef3e00ae0446ac6d84a20ac798/excludelist#L98-L102">source</a>).</p>
<p>The list of libraries that can resp. have to be excluded, the so-called <span class="xref std std-ref">excludelist</span>, is carefully curated by the AppImage team, and is regularly updated.</p>
</div>
<div class="section" id="appimage-specification">
<span id="id2"></span><h4><a class="toc-backref" href="#id6">AppImage specification</a><a class="headerlink" href="#appimage-specification" title="Permalink to this headline">¶</a></h4>
<p>The term <em>AppImage</em> does not refer to some software project, but is actually a standard specified in the <a class="reference internal" href="index.html#ref-appimage-specification"><span class="std std-ref">AppImage specification</span></a>. Its reference implementation is called <a class="reference internal" href="index.html#ref-appimagekit"><span class="std std-ref">AppImageKit</span></a>.</p>
<p>Being designed as a standard with a reference implementation allows users to implement their own tools to build AppImages, and helps maintaining compatibility between different tools and components.</p>
</div>
<div class="section" id="appdirs">
<h4><a class="toc-backref" href="#id7">AppDirs</a><a class="headerlink" href="#appdirs" title="Permalink to this headline">¶</a></h4>
<p>The term <em>AppDir</em> refers to an application directory. These directories are the “source” of AppImages. When <span class="xref std std-ref">appimagetool</span> builds an AppImage, it creates a read-only image of such a directory, prepends the <span class="xref std std-ref">runtime</span>, and marks the file executable.</p>
<p>The AppDir format is described in the <span class="xref std std-ref">appdir-description</span>.</p>
</div>
</div>
<span id="document-introduction/software-overview"></span><div class="section" id="software-overview">
<span id="id1"></span><h3>Software Overview<a class="headerlink" href="#software-overview" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<ul class="simple">
<li><p>list deprecated components</p></li>
</ul>
</div>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#appimage-project" id="id13">AppImage project</a></p>
<ul>
<li><p><a class="reference internal" href="#appimagekit" id="id14">AppImageKit</a></p></li>
<li><p><a class="reference internal" href="#appimageupdate" id="id15">AppImageUpdate</a></p></li>
<li><p><a class="reference internal" href="#appimaged" id="id16">appimaged</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#third-party-tools" id="id17">Third-party tools</a></p>
<ul>
<li><p><a class="reference internal" href="#linuxdeployqt" id="id18">linuxdeployqt</a></p></li>
<li><p><a class="reference internal" href="#linuxdeploy" id="id19">linuxdeploy</a></p></li>
<li><p><a class="reference internal" href="#appimagelauncher" id="id20">AppImageLauncher</a></p></li>
<li><p><a class="reference internal" href="#nx-software-center" id="id21">NX Software Center</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="appimage-project">
<h4><a class="toc-backref" href="#id13">AppImage project</a><a class="headerlink" href="#appimage-project" title="Permalink to this headline">¶</a></h4>
<div class="section" id="appimagekit">
<span id="ref-appimagekit"></span><h5><a class="toc-backref" href="#id14">AppImageKit</a><a class="headerlink" href="#appimagekit" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="https://github.com/AppImage/AppImageKit">AppImageKit</a> is the reference implementation of the <a class="reference internal" href="index.html#appimage-specification"><span class="std std-ref">AppImage specification</span></a>. It is split up into several components, which are described in this subsection.</p>
<div class="section" id="runtime">
<span id="ref-runtime"></span><h6>runtime<a class="headerlink" href="#runtime" title="Permalink to this headline">¶</a></h6>
<p>The runtime provides the “executable header” of every AppImage. When executing an AppImage, the runtime within the AppImage is run, which mounts the embedded file system image read-only in a temporary location, and launches the payload application within there. After the payload application exited, the runtime unmounts the squashfs image and cleans up the temporary resources (such as, the temporary mountpoint directory).</p>
<p><strong>Download:</strong> There is usually no reason to download this manually, but if you still want to, you can get it from <a class="reference external" href="https://github.com/AppImage/AppImageKit/releases/continuous">https://github.com/AppImage/AppImageKit/releases/continuous</a>. Keep in mind that on its own it does nothing, it needs to be combined with a filesystem image to form a valid AppImage, usually by using appimagetool which comes with its own copy of the runtime.</p>
</div>
<div class="section" id="appimagetool">
<span id="ref-appimagetool"></span><h6>appimagetool<a class="headerlink" href="#appimagetool" title="Permalink to this headline">¶</a></h6>
<p>appimagetool is the easiest way to create AppImages from existing directories on the system, the so-called :ref:<a href="#id4"><span class="problematic" id="id5">`</span></a>AppDir`s. It creates the AppImage by embedding the runtime, and creating and appending the filesystem image.</p>
<p>appimagetool implements all optional features, like for instance <span class="xref std std-ref">update information</span>, <span class="xref std std-ref">signing</span>, and some linting options to make sure the information in the AppImage is valid (for instance, it can validate <span class="xref std std-ref">AppStream files</span>).</p>
<p><strong>Download:</strong> You can get it as an AppImage from <a class="reference external" href="https://github.com/AppImage/AppImageKit/releases/continuous">https://github.com/AppImage/AppImageKit/releases/continuous</a>.</p>
</div>
<div class="section" id="apprun">
<h6>AppRun<a class="headerlink" href="#apprun" title="Permalink to this headline">¶</a></h6>
<p>Every AppImage’s AppDir must contain a file called <code class="code docutils literal notranslate"><span class="pre">AppRun</span></code>, providing the “entry point”. When running the AppImage, the <span class="xref std std-ref">runtime</span> executes the <code class="code docutils literal notranslate"><span class="pre">AppRun</span></code> file within the <span class="xref std std-ref">AppDir</span>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">AppRun</span></code> doesn’t necessarily have to be a regular file. If the application is <span class="xref std std-ref">relocatable</span>, it can just be a symlink to the main binary. Tools like <span class="xref std std-ref">linuxdeploy</span> can turn applications into relocatable applications, and therefore create such a symlink.</p>
<p>In some cases, though, when an existing application must not be altered (e.g., when the license prohibits any modifications) or tools like linuxdeploy cannot be used, AppImageKit’s <code class="code docutils literal notranslate"><span class="pre">AppRun.c</span></code> can be used. <code class="code docutils literal notranslate"><span class="pre">AppRun.c</span></code> attempts to make programs load bundled shared libraries instead of system ones by manipulating environment variable. Furthermore, it attempts to prevent warnings users might encounter that are coming from the fact the <span class="xref std std-ref">AppDir</span> is mounted read-only.</p>
<p>Using <code class="code docutils literal notranslate"><span class="pre">AppRun.c</span></code> is not a guarantee that an application will run, and the packager must provide all the resources an application could need manually (or by using external tools) before creating the AppImage with <span class="xref std std-ref">appimagetool</span>. <code class="code docutils literal notranslate"><span class="pre">AppRun</span></code> force-changes the current working directory, and therefore applications can not detect where the AppImage was called originally. This may be especially annoying for CLI tools, but can also be a problem for GUI applications expecting paths via parameters.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">AppRun.c</span></code>, the binary from AppImageKit, is legacy technology and should be avoided if possible. Tools like <span class="xref std std-ref">linuxdeploy</span> deploy applications in a different way (they are smart enough so that a simple symlink called <code class="code docutils literal notranslate"><span class="pre">AppRun</span></code> to the main binary works just fine), and made using <code class="code docutils literal notranslate"><span class="pre">AppRun.c</span></code> obsolete in most cases.</p>
<p>There are some edge cases where <code class="code docutils literal notranslate"><span class="pre">AppRun.c</span></code> is still in use, and there it might be useful. However, it suffers from many limitations and requires some workarounds (which require troublesome mechanisms, such as e.g., force-changing current working directory, as described in this section), which can cause a lot of trouble while trying to debug an AppImage. Please beware of these before thinking about using <code class="code docutils literal notranslate"><span class="pre">AppRun.c</span></code> in your AppImage.</p>
</div>
<p><strong>Download:</strong> There is usually no reason to download this manually, but if you still want to, you can get it from <a class="reference external" href="https://github.com/AppImage/AppImageKit/releases/continuous">https://github.com/AppImage/AppImageKit/releases/continuous</a>.</p>
</div>
<div class="section" id="helpers">
<h6>Helpers<a class="headerlink" href="#helpers" title="Permalink to this headline">¶</a></h6>
<p>AppImageKit ships with a few helpers that can be used to verify and validate some AppImage features.</p>
<div class="section" id="validate">
<h7>validate<a class="headerlink" href="#validate" title="Permalink to this headline">¶</a></h7>
<p><code class="code docutils literal notranslate"><span class="pre">validate</span></code> can validate the PGP signatures inside AppImages.</p>
<p>Normally there is no need to use this directly, this is mainly for debugging for AppImage developers.</p>
<p><strong>Download:</strong> Currently this needs to be build from source. The source is in <a class="reference external" href="https://github.com/AppImage/AppImageKit/">https://github.com/AppImage/AppImageKit/</a>. In the future it may become bundled with or its functionality may become integrated into appimagetool.</p>
</div>
<div class="section" id="digest-md5">
<h7>digest-md5<a class="headerlink" href="#digest-md5" title="Permalink to this headline">¶</a></h7>
<p>Calculates the MD5 digest used for desktop integration purposes for a given AppImage. This digest depends on the path, not on the contents.</p>
<p>Normally there is no need to use this directly, this is mainly for debugging for AppImage developers.</p>
<p><strong>Download:</strong> Currently this needs to be build from source. The source is in <a class="reference external" href="https://github.com/AppImage/AppImageKit/">https://github.com/AppImage/AppImageKit/</a>. In the future it may become bundled with or its functionality may become integrated into appimagetool.</p>
</div>
</div>
</div>
<div class="section" id="appimageupdate">
<span id="ref-appimageupdate"></span><h5><a class="toc-backref" href="#id15">AppImageUpdate</a><a class="headerlink" href="#appimageupdate" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="https://github.com/AppImage/AppImageUpdate">AppImageUpdate</a> lets you update AppImages in a decentralized way using information embedded in the AppImage itself.</p>
<p>The project consists of two tools: <code class="code docutils literal notranslate"><span class="pre">appimageupdatetool</span></code>, a full-featured CLI tool for updating AppImages and dealing with <a class="reference external" href="https://github.com/AppImage/AppImageSpec/blob/master/draft.md#update-information">update information</a>, and <code class="code docutils literal notranslate"><span class="pre">AppImageUpdate</span></code>, a user interface for updating AppImages written in Qt.</p>
<p><strong>Download:</strong> You can get it as an AppImage from <a class="reference external" href="https://github.com/AppImage/AppImageUpdate/releases/continuous">https://github.com/AppImage/AppImageUpdate/releases/continuous</a>.</p>
</div>
<div class="section" id="appimaged">
<span id="id7"></span><h5><a class="toc-backref" href="#id16">appimaged</a><a class="headerlink" href="#appimaged" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="https://github.com/AppImage/appimaged">appimaged</a> is a daemon that monitors a predefined set of directories on the system, looking for AppImages. It automatically integrates all AppImages it can find during an initial search, and then live watches for new AppImage (or AppImages that were removed) and (de)integrates these immediately.</p>
<p>It is shipped in a few native distribution package formats as well as as AppImage.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>One of the monitored directories is <code class="docutils literal notranslate"><span class="pre">~/Downloads</span></code>. If the directory is very large, appimaged usually needs quite long to visit all files. It is likely to slow down the system (specifically, the filesystem).</p>
</div>
<p><strong>Download:</strong> You can get it as an AppImage from <a class="reference external" href="https://github.com/AppImage/appimaged/releases/continuous">https://github.com/AppImage/appimaged/releases/continuous</a>.</p>
</div>
</div>
<div class="section" id="third-party-tools">
<h4><a class="toc-backref" href="#id17">Third-party tools</a><a class="headerlink" href="#third-party-tools" title="Permalink to this headline">¶</a></h4>
<p>This section showcases a couple of third-party tools that can be used to create and handle AppImage files.</p>
<div class="section" id="linuxdeployqt">
<h5><a class="toc-backref" href="#id18">linuxdeployqt</a><a class="headerlink" href="#linuxdeployqt" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="https://github.com/probonopd/linuxdeployqt">linuxdeployqt</a> is a simple Qt-based command line tool that can be used to create AppDirs and AppImages. It is based on the similar macdeployqt tool that comes with Qt. It can be used to produce AppDirs and AppImages for C, C++, and Qt/QML applications, as well as applications written in other compiled languages.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>There is a copy-and-paste example for how to use it on Travis CI at <a class="reference external" href="https://github.com/probonopd/linuxdeployqt#using-linuxdeployqt-with-travis-ci">https://github.com/probonopd/linuxdeployqt#using-linuxdeployqt-with-travis-ci</a>.</p>
</div>
<p><strong>Download:</strong> You can get it as an AppImage from <a class="reference external" href="https://github.com/probonopd/linuxdeployqt/releases/tag/continuous">https://github.com/probonopd/linuxdeployqt/releases/tag/continuous</a>.</p>
</div>
<div class="section" id="linuxdeploy">
<h5><a class="toc-backref" href="#id19">linuxdeploy</a><a class="headerlink" href="#linuxdeploy" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy">linuxdeploy</a> is a simple yet flexible, plugins-based to use tool that can be used to create AppDirs and AppImages. It has been developed in 2018, and describes itself as an “AppDir creation and maintenance tool”.</p>
<p>linuxdeploy is planned to succeed of <span class="xref std std-ref">linuxdeployqt</span>, and can be used in all projects that use <span class="xref std std-ref">linuxdeployqt</span>. The list of plugins is continually growing, providing solutions for bundling frameworks such as <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy-plugin-qt">Qt</a> as well as complete environments for non-native programming languages such as <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy-plugin-conda">Python</a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>There’s a guide on <a class="reference internal" href="index.html#ref-packaging-native-binaries"><span class="std std-ref">native binary packaging</span></a> and a general <a class="reference internal" href="index.html#ref-linuxdeploy"><span class="std std-ref">linuxdeploy user guide</span></a> in the <a class="reference internal" href="index.html#ref-packaging-guide"><span class="std std-ref">Packaging Guide</span></a>.</p>
</div>
<p><strong>Download:</strong> You can get it as an AppImage from <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy/releases/continuous">https://github.com/linuxdeploy/linuxdeploy/releases/continuous</a>.</p>
</div>
<div class="section" id="appimagelauncher">
<span id="ref-appimagelauncher"></span><h5><a class="toc-backref" href="#id20">AppImageLauncher</a><a class="headerlink" href="#appimagelauncher" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="https://github.com/TheAssassin/AppImageLauncher">AppImageLauncher</a> is a helper application for Linux distributions serving as a kind of “entry point” for running and integrating AppImages.</p>
<p>Quoting the README:</p>
<blockquote>
<div><p>AppImageLauncher makes your Linux desktop AppImage ready™. By installing it, you won’t ever have to worry about AppImages again. You can always double click them without making them executable first, just like you should be able to do nowadays. You can integrate AppImages with a single mouse click, and manage them from your application launcher. Updating and removing AppImages becomes as easy as never before.</p>
<p>Due to its simple but efficient way to integrate into your system, it plays well with other applications that can be used to manage AppImages, for example app stores. However, it doesn’t depend on any of those, and can run completely standalone.</p>
<p>Install AppImageLauncher today for your distribution and enjoy using AppImages as easy as never before!</p>
<p class="attribution">—<a class="reference external" href="https://github.com/TheAssassin/AppImageLauncher/blob/master/README.md">https://github.com/TheAssassin/AppImageLauncher/blob/master/README.md</a></p>
</div></blockquote>
<p>AppImageLauncher doesn’t provide any kind of “app store” software, but integrates into system-provided launchers’ context menus. It provides tools for updating (based on <span class="xref std std-ref">AppImageUpdate</span>) and removing AppImages.</p>
<p><strong>Download:</strong> You can get AppImageLauncher-Lite as an AppImage and the full version as a deb from <a class="reference external" href="https://github.com/TheAssassin/AppImageLauncher/releases/continuous">https://github.com/TheAssassin/AppImageLauncher/releases/continuous</a>.</p>
</div>
<div class="section" id="nx-software-center">
<h5><a class="toc-backref" href="#id21">NX Software Center</a><a class="headerlink" href="#nx-software-center" title="Permalink to this headline">¶</a></h5>
<p>A portable Software Center for portable applications thanks to AppImage.</p>
<p><strong>Download:</strong> You can get NX Software Center as part of Nitrux OS from <a class="reference external" href="https://nxos.org/">https://nxos.org/</a>. There are currently no recent continuous standalone AppImage builds available.</p>
<div class="admonition-todo admonition" id="id12">
<p class="admonition-title">Todo</p>
<p>Describe the rest of the third-party tools</p>
</div>
</div>
</div>
</div>
<span id="document-introduction/upstream"></span><div class="section" id="a-word-on-upstream-packaging">
<h3>A word on upstream packaging<a class="headerlink" href="#a-word-on-upstream-packaging" title="Permalink to this headline">¶</a></h3>
<p>The AppImage ecosystem is built around the notion of “upstream packaging”. With AppImage, typically the application author is who packages and distributes the application. This is different from the traditional Linux distribution model, where the application author and the application packager (also called the maintainer) are often different persons.</p>
<p>AppimageKit is designed with “upstream packaging” in mind. This means that we want the original author of an application to be the person that packages it as an AppImage, distributes it to end users, and supports it.</p>
<p>In this regard, if image is very similar to an <code class="code docutils literal notranslate"><span class="pre">.exe</span></code> file on Windows or a <code class="code docutils literal notranslate"><span class="pre">.dmg</span></code> file on the Mac. These files are normally prepared by the original application authors rather than by third parties. This ensures that the software works exactly the way the original application author has envisioned it to work. It also means that the application author does not have to follow arbitrary rules set by Linux distributions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before you package an application as an AppImage, ask yourself whether you are either the application author or a member of the application team. If not, it is most likely better to ask the original author of the application or the application team to provide an official AppImage.</p>
</div>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#advantages" id="id1">Advantages</a></p></li>
<li><p><a class="reference internal" href="#disadvantages" id="id2">Disadvantages</a></p></li>
<li><p><a class="reference internal" href="#if-upstream-packaging-is-not-possible" id="id3">If upstream packaging is not possible</a></p></li>
</ul>
</div>
<div class="section" id="advantages">
<h4><a class="toc-backref" href="#id1">Advantages</a><a class="headerlink" href="#advantages" title="Permalink to this headline">¶</a></h4>
<p>Upstream packaging has a lot of advantages:  first and foremost, it allows the application author to control the entire user experience from how the user gets the application to how it works. it also allows the original author of an application to support the application since no unauthorised changes or made to it by third parties. For end-users, it is clear that the original application author is who is responsible for fixing bugs come out as there is no shared responsibility between the application author and the third party, e.g. a Linux distribution, that has distributed the application.</p>
</div>
<div class="section" id="disadvantages">
<h4><a class="toc-backref" href="#id2">Disadvantages</a><a class="headerlink" href="#disadvantages" title="Permalink to this headline">¶</a></h4>
<p>However, upstream packaging also has disadvantages:  most prominently, there is no curator who assesses the quality and integrity of the application. Hence, the end user has to trust the application author when running an application that has been distributed directly by the original application author.</p>
</div>
<div class="section" id="if-upstream-packaging-is-not-possible">
<h4><a class="toc-backref" href="#id3">If upstream packaging is not possible</a><a class="headerlink" href="#if-upstream-packaging-is-not-possible" title="Permalink to this headline">¶</a></h4>
<p>In some cases, the original application author or application team may not be interested in providing an official AppImage. In this case you have the following options: For open source projects, you can often make and send a pull request, and for closed source applications you can create a yml recipe that can be used to convert the existing Linux binaries into an AppImage using <a class="reference internal" href="index.html#ref-pkg2appimage"><span class="std std-ref">pkg2appimage</span></a>.</p>
<div class="section" id="open-source-projects">
<h5>Open source projects<a class="headerlink" href="#open-source-projects" title="Permalink to this headline">¶</a></h5>
<p>For open source projects, you can often make and send a pull request (GitHub) or merge request (GitLab) that generates an AppImage as part of the project’s build pipeline. Most open source projects will gladly accept such pull requests, especially if you indicate that you are willing to maintain the AppImage generation going forward.</p>
<p>Many open source projects already use continuous integration on systems such as Travis CI, GitLab CI, Jenkins, or the <a class="reference internal" href="index.html#ref-obs"><span class="std std-ref">Open Build Service</span></a>. If a project already uses one of those services, it is most beneficial to generate the AppImage on that service.</p>
</div>
<div class="section" id="closed-source-applications">
<h5>Closed source applications<a class="headerlink" href="#closed-source-applications" title="Permalink to this headline">¶</a></h5>
<p>For closed source applications you can create a yml recipe that can be used to convert the existing Linux binaries into an AppImage using <a class="reference internal" href="index.html#ref-pkg2appimage"><span class="std std-ref">pkg2appimage</span></a>).</p>
<p>Note that you may not be allowed to redistribute the AppImage of the application. In this case, you can distribute <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> recipes that end users can use to produce their own AppImages of the application easily. This applies to applications such as Google Chrome, Spotify, Skype, and others.</p>
</div>
</div>
</div>
</div>
</div>
<span id="document-user-guide/index"></span><div class="section" id="user-guide">
<h2>User Guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h2>
<p>This chapter shows users what AppImages are from a user perspective, how they can be used, what desktop integration is and how it is accomplished, and what other tools are provided to manage, update etc. AppImages.</p>
<div class="toctree-wrapper compound">
<span id="document-user-guide/faq"></span><div class="section" id="frequently-asked-questions">
<span id="faq"></span><h3>Frequently Asked Questions<a class="headerlink" href="#frequently-asked-questions" title="Permalink to this headline">¶</a></h3>
<p>The most common questions are answered directly here to save you from having to read the entire user guide.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#question-what-is-an-appimage" id="id1">question What is an AppImage?</a></p></li>
<li><p><a class="reference internal" href="#question-how-do-i-run-an-appimage" id="id2">question How do I run an AppImage?</a></p></li>
<li><p><a class="reference internal" href="#question-how-can-i-integrate-appimages-with-the-system" id="id3">question How can I integrate AppImages with the system?</a></p></li>
<li><p><a class="reference internal" href="#question-where-can-i-download-appimages" id="id4">question Where can I download AppImages?</a></p></li>
<li><p><a class="reference internal" href="#question-where-do-i-store-my-appimages" id="id5">question Where do I store my AppImages?</a></p></li>
<li><p><a class="reference internal" href="#question-where-can-i-request-appimages" id="id6">question Where can I request AppImages?</a></p></li>
<li><p><a class="reference internal" href="#question-where-do-i-get-support" id="id7">question Where do I get support?</a></p></li>
</ul>
</div>
<div class="section" id="question-what-is-an-appimage">
<h4><a class="toc-backref" href="#id1"><img alt="question" src="_images/question.png" /> What is an AppImage?</a><a class="headerlink" href="#question-what-is-an-appimage" title="Permalink to this headline">¶</a></h4>
<p>An AppImage is a downloadable file for Linux that contains an application and everything the application needs to run (e.g., libraries, icons, fonts, translations, etc.) that cannot be reasonably expected to be part of each target system.</p>
</div>
<div class="section" id="question-how-do-i-run-an-appimage">
<h4><a class="toc-backref" href="#id2"><img alt="question" src="_images/question.png" /> How do I run an AppImage?</a><a class="headerlink" href="#question-how-do-i-run-an-appimage" title="Permalink to this headline">¶</a></h4>
<p>Make it executable and double-click it.</p>
</div>
<div class="section" id="question-how-can-i-integrate-appimages-with-the-system">
<h4><a class="toc-backref" href="#id3"><img alt="question" src="_images/question.png" /> How can I integrate AppImages with the system?</a><a class="headerlink" href="#question-how-can-i-integrate-appimages-with-the-system" title="Permalink to this headline">¶</a></h4>
<p>Using the optional appimaged daemon, you can easily integrate AppImages with the system. The daemon puts AppImages into the menus, registers MIME types, icons, all on the fly. You can download it from this repository. But it is entirely optional.</p>
</div>
<div class="section" id="question-where-can-i-download-appimages">
<h4><a class="toc-backref" href="#id4"><img alt="question" src="_images/question.png" /> Where can I download AppImages?</a><a class="headerlink" href="#question-where-can-i-download-appimages" title="Permalink to this headline">¶</a></h4>
<p>See the “repository” of upstream-generated AppImages.</p>
</div>
<div class="section" id="question-where-do-i-store-my-appimages">
<h4><a class="toc-backref" href="#id5"><img alt="question" src="_images/question.png" /> Where do I store my AppImages?</a><a class="headerlink" href="#question-where-do-i-store-my-appimages" title="Permalink to this headline">¶</a></h4>
<p>An important point about the AppImage format is that you can store AppImage files wherever you want. This includes your home directory, your downloads directory, a dedicated applications directory, a USB thumb drive, a CD-ROM or DVD, or even a network file share. No matter where you keep your AppImages, you are still able to run them. This is very similar to how applications work on macOS. Unlike with traditional Linux packages, you do not need to install AppImages or put them into some special location in order for them to work.</p>
<p>If you don’t want to leave them in <code class="code docutils literal notranslate"><span class="pre">$HOME/Downloads</span></code>, then <code class="code docutils literal notranslate"><span class="pre">$HOME/Applications</span></code> is a good choice. Many third-party tools (especially the ones managing desktop integration) use this location, too. Other options involve <code class="code docutils literal notranslate"><span class="pre">$HOME/.local/bin</span></code> and <code class="code docutils literal notranslate"><span class="pre">$HOME/bin</span></code>, which are useful mainly for CLI tools.</p>
<p><strong>On CentOS/RHEL and Fedora:</strong> When you login, the script <code class="code docutils literal notranslate"><span class="pre">$HOME/.bash_profile</span></code> is executed and this script adds <code class="code docutils literal notranslate"><span class="pre">$HOME/.local/bin:$HOME/bin</span></code> to your path.</p>
<p><strong>On Ubuntu:</strong> When you login, the script <code class="code docutils literal notranslate"><span class="pre">$HOME/.profile</span></code> is executed and this script adds <code class="code docutils literal notranslate"><span class="pre">&quot;$HOME/bin:$HOME/.local/bin&quot;</span></code> to your path.</p>
<p>Besides, every other location works, e.g., a USB thumbdrive, a network location, or a CD-ROM, but then the AppImages won’t be on your path, which means that you cannot simply type their name into a terminal but have to use the full path.</p>
</div>
<div class="section" id="question-where-can-i-request-appimages">
<h4><a class="toc-backref" href="#id6"><img alt="question" src="_images/question.png" /> Where can I request AppImages?</a><a class="headerlink" href="#question-where-can-i-request-appimages" title="Permalink to this headline">¶</a></h4>
<p>If there is no AppImage of your favorite application available, please request it from the author(s) of the application, e.g., as a feature request in the issue tracker of the application.</p>
<p>For example, if you would like to see an AppImage of Mozilla Firefox, then please leave a comment at <a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1249971">https://bugzilla.mozilla.org/show_bug.cgi?id=1249971</a>. The more people request an AppImage from the upstream authors, the more likely is that an AppImage will be provided.</p>
</div>
<div class="section" id="question-where-do-i-get-support">
<h4><a class="toc-backref" href="#id7"><img alt="question" src="_images/question.png" /> Where do I get support?</a><a class="headerlink" href="#question-where-do-i-get-support" title="Permalink to this headline">¶</a></h4>
<p>Please refer to the <a class="reference internal" href="index.html#ref-contact"><span class="std std-ref">contact page</span></a>.</p>
</div>
</div>
<span id="document-user-guide/run-appimages"></span><div class="section" id="running-appimages">
<h3>Running AppImages<a class="headerlink" href="#running-appimages" title="Permalink to this headline">¶</a></h3>
<p>This page shows how a user can run AppImages, on their favorite distribution using the desktop environment tools or via the terminal. Also, it explains the concept of desktop integration, and presents tools that can be used for this purpose.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#download-make-executable-run" id="id4">Download, make executable, run</a></p></li>
<li><p><a class="reference internal" href="#mount-or-extract-appimages" id="id5">Mount or extract AppImages</a></p>
<ul>
<li><p><a class="reference internal" href="#mount-an-appimage" id="id6">Mount an AppImage</a></p></li>
<li><p><a class="reference internal" href="#extract-the-contents-of-an-appimage" id="id7">Extract the contents of an AppImage</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#integrating-appimages-into-the-desktop" id="id8">Integrating AppImages into the desktop</a></p>
<ul>
<li><p><a class="reference internal" href="#appimaged" id="id9">appimaged</a></p></li>
<li><p><a class="reference internal" href="#appimagelauncher" id="id10">AppImageLauncher</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#troubleshooting" id="id11">Troubleshooting</a></p></li>
</ul>
</div>
<div class="section" id="download-make-executable-run">
<span id="ref-download-make-executable-run"></span><h4><a class="toc-backref" href="#id4">Download, make executable, run</a><a class="headerlink" href="#download-make-executable-run" title="Permalink to this headline">¶</a></h4>
<p>It’s quite simple to run AppImages. As the heading says, just download them, make them executable and run them. This can either be done using the GUI or via the command line.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Information on how to run AppImages was moved into our <a class="reference internal" href="index.html#ref-quickstart"><span class="std std-ref">Quickstart</span></a> page.</p>
<p>Please see <a class="reference internal" href="index.html#ref-how-to-run-appimage"><span class="std std-ref">How to run an AppImage</span></a> for more information.</p>
</div>
</div>
<div class="section" id="mount-or-extract-appimages">
<h4><a class="toc-backref" href="#id5">Mount or extract AppImages</a><a class="headerlink" href="#mount-or-extract-appimages" title="Permalink to this headline">¶</a></h4>
<p>To inspect the contents of any AppImage, it is possible to either mount them without running them, or extract the contents to a directory in the current working directory..</p>
<div class="section" id="mount-an-appimage">
<h5><a class="toc-backref" href="#id6">Mount an AppImage</a><a class="headerlink" href="#mount-an-appimage" title="Permalink to this headline">¶</a></h5>
<p>AppImages can be mounted in the system to provide <em>read-only</em> access for users to allow for inspecting the contents.</p>
<p>To mount an AppImage temporarily, you have two options. The easiest way to do so is to call AppImages with the special parameter <code class="docutils literal notranslate"><span class="pre">--appimage-mount</span></code>, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">my</span><span class="o">.</span><span class="n">AppImage</span> <span class="o">--</span><span class="n">appimage</span><span class="o">-</span><span class="n">mount</span>
<span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">mount_myXXXX</span>
<span class="c1"># now, use another terminal or file manager to inspect the contents in the directory printed by --appimage-mount</span>
</pre></div>
</div>
<p>The AppImage is unmounted when the application called in the example is interrupted (e.g., by pressing <kbd class="kbd docutils literal notranslate">Ctrl+C</kbd>, closing the terminal etc.).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is only available for type 2 AppImages. Type 1 AppImages do not provide any self-mounting mechanism. To mount type 1 AppImages, use <code class="docutils literal notranslate"><span class="pre">mount</span> <span class="pre">-o</span> <span class="pre">loop</span></code>.</p>
</div>
<p>This method is to be preferable, as other methods have some major disadvantages explained below.</p>
<p>Another way to mount AppImages is to use the normal <code class="docutils literal notranslate"><span class="pre">mount</span></code> command toolchain of your Linux distribution. Mounting and unmounting devices, files, images and also AppImages requires root permissions. Also, you need to provide a mountpoint. Please see the following example:</p>
<p>For type 1 AppImages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">mkdir</span> <span class="n">mountpoint</span>
<span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">mount</span> <span class="n">my</span><span class="o">.</span><span class="n">AppImage</span> <span class="n">mountpoint</span><span class="o">/</span>
<span class="c1"># you can now inspect the contents</span>
<span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">umount</span> <span class="n">mountpoint</span><span class="o">/</span>
</pre></div>
</div>
<p>For type 2 AppImages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">mkdir</span> <span class="n">mountpoint</span>
<span class="o">&gt;</span> <span class="n">my</span><span class="o">.</span><span class="n">AppImage</span> <span class="o">--</span><span class="n">appimage</span><span class="o">-</span><span class="n">offset</span>
<span class="o">&gt;</span> <span class="mi">123456</span>
<span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">mount</span> <span class="n">my</span><span class="o">.</span><span class="n">AppImage</span> <span class="n">mountpoint</span><span class="o">/</span> <span class="o">-</span><span class="n">o</span> <span class="n">offset</span><span class="o">=</span><span class="mi">123456</span>
<span class="c1"># you can now inspect the contents</span>
<span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">umount</span> <span class="n">mountpoint</span><span class="o">/</span>
</pre></div>
</div>
<p>Note that the number <cite>123456</cite> is just an example here, you will likely see another number.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>AppImages mounted using this method are not unmounted automatically. Please do not forget to call <code class="docutils literal notranslate"><span class="pre">umount</span></code> the AppImage as soon as you don’t need it mounted any more.</p>
<p>If an AppImage is not unmounted properly, and is moved to a new location, a so-called “dangling mount” can be created. This should be avoided by properly unmounting the AppImages.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Type 2 AppImages which are mounted using the <code class="docutils literal notranslate"><span class="pre">--appimage-mount</span></code> parameter are <strong>not</strong> affected by this problem!</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>There is currently no way to use the former method without calling the target AppImage. This might not always be appropriate, e.g., if the AppImage is not trustworthy.</p>
<p>The AppImage team is working on implementing a mount option in <a class="reference internal" href="index.html#ref-appimagetool"><span class="std std-ref">appimagetool</span></a>. Please see the related <a class="reference external" href="https://github.com/AppImage/AppImageKit/issues/830">GitHub issue</a> for progress on this.</p>
</div>
</div>
<div class="section" id="extract-the-contents-of-an-appimage">
<h5><a class="toc-backref" href="#id7">Extract the contents of an AppImage</a><a class="headerlink" href="#extract-the-contents-of-an-appimage" title="Permalink to this headline">¶</a></h5>
<p>An alternative to mounting the AppImages is to extract their contents. This allows for modifying the contents. The resulting directory is a valid <span class="xref std std-ref">AppDir</span>, and users can create AppImages from them again using <a class="reference internal" href="index.html#ref-appimagetool"><span class="std std-ref">appimagetool</span></a>.</p>
<p>Analog to mounting AppImages, there is a simple commandline switch to extract the contents of type 2 AppImages without external tools. Just call the AppImage with the parameter <code class="code docutils literal notranslate"><span class="pre">--appimage-extract</span></code>. This will cause the <a class="reference internal" href="index.html#ref-runtime"><span class="std std-ref">runtime</span></a> to create a new directory called <code class="code docutils literal notranslate"><span class="pre">squashfs-root</span></code>, containing the contents of the AppImage’s <a class="reference internal" href="index.html#ref-appdir"><span class="std std-ref">AppDir specification</span></a>.</p>
<p>Type 1 AppImages require the deprecated tool <a class="reference external" href="https://github.com/AppImage/AppImageKit/releases/6">AppImageExtract</a> to extract the contents of an AppImage. It’s very limited functionality wise, and requires a GUI to run. It creates a new directory in the user’s desktop directory.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>There is currently no way to use the former method without calling the target AppImage. This might not always be appropriate, e.g., if the AppImage is not trustworthy.</p>
<p>The AppImage team is working on implementing a mount option in <a class="reference internal" href="index.html#ref-appimagetool"><span class="std std-ref">appimagetool</span></a>. Please see the related <a class="reference external" href="https://github.com/AppImage/AppImageKit/issues/830">GitHub issue</a> for progress on this.</p>
</div>
</div>
</div>
<div class="section" id="integrating-appimages-into-the-desktop">
<h4><a class="toc-backref" href="#id8">Integrating AppImages into the desktop</a><a class="headerlink" href="#integrating-appimages-into-the-desktop" title="Permalink to this headline">¶</a></h4>
<p>AppImages are standalone bundles, and do not need to be <em>installed</em>. However, some users may want their AppImages to be available like distribution provided applications. This primarily involves being able to launch desktop applications from their desktop environments’ launchers. This concept is called <em>desktop integration</em>.</p>
<div class="section" id="appimaged">
<h5><a class="toc-backref" href="#id9">appimaged</a><a class="headerlink" href="#appimaged" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="https://github.com/AppImage/appimaged">appimaged</a> is a daemon that monitors the system and integrates AppImages. It monitors a predefined set of directories on the user’s system searching for AppImages, and integrates them into the system using <span class="xref std std-ref">libappimage</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>More information on appimaged can be found in <span class="xref std std-ref">appimaged</span>.</p>
</div>
</div>
<div class="section" id="appimagelauncher">
<h5><a class="toc-backref" href="#id10">AppImageLauncher</a><a class="headerlink" href="#appimagelauncher" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="https://github.com/TheAssassin/AppImageLauncher">AppImageLauncher</a> is a helper application for Linux distributions serving as a kind of “entry point” for running and integrating AppImages. It makes a user’s system AppImage-ready™.</p>
<p>AppImageLauncher must be installed into the system to be able to integrate into the system properly. It uses technologies that are independent from any desktop environment features, and therefore should be able to run on most distributions.</p>
<p>After install AppImageLauncher, you can simply double-click AppImages in file managers, browsers etc. You will be prompted whether to integrate the AppImage, or run it just once. When you choose to integrate your AppImage, the file will be moved into the directory <code class="code docutils literal notranslate"><span class="pre">~/Applications</span></code>. This helps reducing the mess of AppImages on your file system and prevents you from having to search for the actual AppImage file if you want to e.g., remove it.</p>
<p>To provide a complete solution for managing AppImages on the system, AppImageLauncher furthermore provides solutions for updating and removing AppImages from the system. These functions can be found in the context menus of the entries in the desktop’s launcher.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>More information about AppImageLauncher can be found in <a class="reference internal" href="index.html#ref-appimagelauncher"><span class="std std-ref">AppImageLauncher</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="troubleshooting">
<h4><a class="toc-backref" href="#id11">Troubleshooting</a><a class="headerlink" href="#troubleshooting" title="Permalink to this headline">¶</a></h4>
<p>Please refer to our <a class="reference internal" href="index.html#ref-ug-troubleshooting"><span class="std std-ref">Troubleshooting page</span></a>.</p>
</div>
</div>
<span id="document-user-guide/portable-mode"></span><div class="section" id="using-portable-mode">
<h3>Using portable mode<a class="headerlink" href="#using-portable-mode" title="Permalink to this headline">¶</a></h3>
<p>This page describes a mode some newer AppImages (i.e., built in 2017 or later) provide, the <em>portable mode</em>. This mode allows for bundling an application’s data next to the application’s AppImage.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#example" id="id2">Example</a></p></li>
</ul>
</div>
<div class="section" id="introduction">
<h4><a class="toc-backref" href="#id1">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p>Sometimes it can be useful for data of an application to travel along with the application, for example to put the application on a USB stick that can be used with different computers. In the windows world, this concept is known as “portable applications”.</p>
<p>Normally the application contained inside an AppImage will store its configuration files wherever it always stores them (most frequently somewhere inside <code class="code docutils literal notranslate"><span class="pre">$HOME</span></code>). In other words, the fact that an application is contained inside an AppImage normally does not change where the application stores its data.</p>
<p>However, there is functionality in newer AppImages that can make the application’s data travel along with the application, if certain directories are present <em>next to the AppImage file</em>.</p>
<p>If you invoke an AppImage built with a recent version of AppImageKit and have one of these special directories in place, then the configuration files will be stored alongside the AppImage. This can be useful for portable use cases, e.g., carrying an AppImage on a USB stick, along with its data.</p>
<ul class="simple">
<li><p>If there is a directory with the same name as the AppImage plus <code class="code docutils literal notranslate"><span class="pre">.home</span></code>, then <code class="code docutils literal notranslate"><span class="pre">$HOME</span></code> will automatically be set to it before executing the payload application</p></li>
<li><p>If there is a directory with the same name as the AppImage plus <code class="code docutils literal notranslate"><span class="pre">.config</span></code>, then <code class="code docutils literal notranslate"><span class="pre">$XDG_CONFIG_HOME</span></code> will automatically be set to it before executing the payload application</p></li>
</ul>
</div>
<div class="section" id="example">
<h4><a class="toc-backref" href="#id2">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>Imagine you want to use the Leafpad text editor, but carry its settings around with the executable. You can do the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Download Leafpad AppImage and make it executable</span>
$ wget -c <span class="s2">&quot;https://bintray.com/probono/AppImages/download_file?file_path=Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage&quot;</span> -O Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage
$ chmod a+x Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage

<span class="c1"># Create a directory with the same name as the AppImage plus the &quot;.config&quot; extension</span>
<span class="c1"># in the same directory as the AppImage</span>
$ mkdir Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage.config

<span class="c1"># Run Leafpad, change some setting (e.g., change the default font size) then close Leafpad</span>
$ ./Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage

<span class="c1"># Now, check where the settings were written:</span>
$ find Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage.config
<span class="o">(</span>...<span class="o">)</span>
Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage.config/leafpad/leafpadrc
</pre></div>
</div>
<p>Note that the file <code class="code docutils literal notranslate"><span class="pre">leafpadrc</span></code> was written in the directory we have created before.</p>
</div>
</div>
<span id="document-user-guide/mac"></span><div class="section" id="appimage-for-macos-switchers">
<h3>AppImage for macOS switchers<a class="headerlink" href="#appimage-for-macos-switchers" title="Permalink to this headline">¶</a></h3>
<img alt="https://user-images.githubusercontent.com/2480569/29998412-7f0f9416-902a-11e7-9d5f-472649e1af34.png" src="https://user-images.githubusercontent.com/2480569/29998412-7f0f9416-902a-11e7-9d5f-472649e1af34.png" />
<p>This page compares the AppImage terms to its macOS equivalents. It
should help macOS to Linux switchers to “get” AppImage concepts quickly.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>AppImage concept</p></th>
<th class="head"><p>Rough macOS equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.AppImage</span></code> file</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.app</span></code> inside a <code class="docutils literal notranslate"><span class="pre">.dmg</span></code> file
that mounts itself automatically
when executed</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.AppDir</span></code> directory</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.app</span></code> directory</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.desktop</span></code> file</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Info.plist</span></code> file</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*.metainfo.xml</span></code> file and  <code class="docutils literal notranslate"><span class="pre">package.json</span></code> file (for  Electron apps)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Info.plist</span></code> file (more elaborate version thereof)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usr/</span></code> inside the AppDir</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Resources/</span></code> inside the <code class="docutils literal notranslate"><span class="pre">.app</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://github.com/AppImage/AppImageUpdate">AppImageUpdate</a></p></td>
<td><p><a class="reference external" href="https://sparkle-project.org/">Sparkle Framework</a></p></td>
</tr>
<tr class="row-even"><td><p>No direct equivalent, but <a class="reference external" href="https://github.com/AppImage/AppImageSpec/blob/master/draft.md#update-information">update information</a> in ELF section <code class="docutils literal notranslate"><span class="pre">.upd_info</span></code></p></td>
<td><p><a class="reference external" href="https://sparkle-project.org/">Sparkle appcast</a></p></td>
</tr>
<tr class="row-odd"><td><p>Optional <code class="docutils literal notranslate"><span class="pre">appimaged</span></code> daemon</p></td>
<td><p><a class="reference external" href="https://developer.apple.com/documentation/coreservices/launch_services">Launch Services</a> to register applications in the system (e.g., MIME types, icons, etc.)</p></td>
</tr>
<tr class="row-even"><td><p>No direct equivalent, but <a class="reference external" href="https://github.com/appimage/appimage.github.io">AppImageHub</a> central directory of available AppImages</p></td>
<td><p>Mac App Store</p></td>
</tr>
<tr class="row-odd"><td><p>Optional signature in ELF section</p></td>
<td><p>Signatures in <code class="docutils literal notranslate"><span class="pre">/Contents/_MASReceipt/</span></code></p></td>
</tr>
<tr class="row-even"><td><p>No direct equivalent (yet?), but use <a class="reference external" href="https://github.com/probonopd/linuxdeployqt">linuxdeployqt</a> (for Qt, C++, C) or
<a class="reference external" href="https://github.com/electron-userland/electron-builder">electron-builder</a> for Electron apps in the build chain</p></td>
<td><p><strong>Xcode</strong> IDE generates <code class="docutils literal notranslate"><span class="pre">.app</span></code>  when you click “compile”</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">appimagetool</span> <span class="pre">my.AppDir</span> <span class="pre">my.AppImage</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">hdiutil</span> <span class="pre">create</span> <span class="pre">-volname</span> <span class="pre">myApp</span> <span class="pre">-srcfolder</span> <span class="pre">my.app/../</span> <span class="pre">-ov</span> <span class="pre">-format</span> <span class="pre">UDZO</span> <span class="pre">myApp.dmg</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<span id="document-user-guide/troubleshooting"></span><div class="section" id="troubleshooting">
<span id="ref-ug-troubleshooting"></span><h3>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Permalink to this headline">¶</a></h3>
<p>This page covers some of the most common problems with AppImages users might face, and provides solutions and links to external references. This page is not considered to be exhaustive. For additional help, please see the <a class="reference internal" href="index.html#ref-contact"><span class="std std-ref">Contact page</span></a>.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#i-get-some-errors-related-to-something-called-fuse" id="id1">I get some errors related to something called “FUSE”</a></p></li>
<li><p><a class="reference internal" href="#i-have-issues-with-electron-based-appimages-and-their-sandboxing" id="id2">I have issues with Electron-based AppImages and their sandboxing</a></p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you as a user think there are errors on this page or you would like to have some additional problems covered, please do not hesitate to <a class="reference external" href="https://github.com/AppImage/docs.appimage.org/issues/new">create an issue</a> on <a class="reference external" href="https://github.com/AppImage/docs.appimage.org">GitHub</a> (or ideally send a pull request right away). We’re always open for feedback!</p>
</div>
<div class="section" id="i-get-some-errors-related-to-something-called-fuse">
<h4><a class="toc-backref" href="#id1">I get some errors related to something called “FUSE”</a><a class="headerlink" href="#i-get-some-errors-related-to-something-called-fuse" title="Permalink to this headline">¶</a></h4>
<p>AppImages require a Linux technology called <em>Filesystem in Userspace</em> (or short <em>FUSE</em>). The majority of systems ships with a working FUSE setup. However, sometimes, it doesn’t quite work. This section explains a few solutions that fix the most frequently reported problems.</p>
<div class="section" id="the-appimage-tells-me-it-needs-fuse-to-run">
<h5>The AppImage tells me it needs FUSE to run<a class="headerlink" href="#the-appimage-tells-me-it-needs-fuse-to-run" title="Permalink to this headline">¶</a></h5>
<p>Sometimes, an AppImage writes the following message to the console:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>AppImages require FUSE to run.
You might still be able to extract the contents of this AppImage
if you run it with the --appimage-extract option.
See https://github.com/AppImage/AppImageKit/wiki/FUSE
for more information
</pre></div>
</div>
<p>In this case, FUSE is not properly set up on your system. You will have to <a class="reference internal" href="#ref-install-fuse"><span class="std std-ref">install FUSE</span></a> in order to fix the problem.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When trying to run AppImages which weren’t built specifically for your platform, you might see this message as well, even if it doesn’t occur while using AppImages built for your platform. Please see <a class="reference internal" href="#ref-warning-fuse-cross-architecture"><span class="std std-ref">these instructions</span></a> on how to fix the issue.</p>
</div>
</div>
<div class="section" id="install-fuse">
<span id="ref-install-fuse"></span><h5>Install FUSE<a class="headerlink" href="#install-fuse" title="Permalink to this headline">¶</a></h5>
<p>Most Linux distributions come with a functional FUSE setup. However, if it is not working for you, you may have to install and configure FUSE yourself.</p>
<p>The process of installing FUSE highly differs from distribution to distribution. This section shows how to install FUSE on the most common distributions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If your distribution is not listed, please ask the distribution developers for instructions.</p>
</div>
<p class="rubric">Setting up FUSE on Ubuntu, Debian and their derivatives</p>
<p>Install the required package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">fuse</span>
</pre></div>
</div>
<p>Now, FUSE should be working. On some older distributions, you will have to run some additional configuration steps:</p>
<p>Make sure the FUSE kernel module is loaded:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">modprobe</span> <span class="o">-</span><span class="n">v</span> <span class="n">fuse</span>
</pre></div>
</div>
<p>Then, add the required group (should be created by the install command, if this is the case, this call <em>will</em> fail), and add your own user account to this group:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&gt; sudo addgroup fuse
&gt; sudo adduser $USER fuse
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>After adding users to groups, these users must logout and login again for the change to take effect!</p>
</div>
<p class="rubric">Setting up FUSE on openSUSE</p>
<p>Install the required package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">zypper</span> <span class="n">install</span> <span class="n">fuse</span>
</pre></div>
</div>
<p>FUSE should now be working.</p>
<p class="rubric">Setting up FUSE on CentOS and RHEL</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following instructions may be out of date. Contributions welcome!</p>
</div>
<p>Install FUSE from EPEL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">yum</span> <span class="o">--</span><span class="n">enablerepo</span><span class="o">=</span><span class="n">epel</span> <span class="n">install</span> <span class="n">fuse</span><span class="o">-</span><span class="n">sshfs</span>
</pre></div>
</div>
<p>Now, add yourself to the related group in order to authorize yourself for using FUSE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&gt; usermod -a -G fuse $(whoami)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>After adding users to groups, these users must logout and login again for the change to take effect!</p>
</div>
<div class="admonition warning" id="ref-warning-fuse-cross-architecture">
<p class="admonition-title">Warning</p>
<p>If you are on a 64-bit system and want to run 32-bit AppImages (e.g., <code class="docutils literal notranslate"><span class="pre">x86_64</span></code>/<code class="docutils literal notranslate"><span class="pre">amd64</span></code> to <code class="docutils literal notranslate"><span class="pre">i386</span></code>, or <code class="docutils literal notranslate"><span class="pre">arm64</span></code> to <code class="docutils literal notranslate"><span class="pre">armhf</span></code>), you will have to install the FUSE runtime libraries for those architectures.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">libfuse2</span><span class="p">:</span><span class="n">i386</span>
<span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">libfuse2</span><span class="p">:</span><span class="n">armhf</span>
</pre></div>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>For more information on how AppImages use FUSE, please see <span class="xref std std-ref">ref-fuse</span>.</p>
</div>
</div>
</div>
<div class="section" id="i-have-issues-with-electron-based-appimages-and-their-sandboxing">
<span id="ref-troubleshooting-electron"></span><h4><a class="toc-backref" href="#id2">I have issues with Electron-based AppImages and their sandboxing</a><a class="headerlink" href="#i-have-issues-with-electron-based-appimages-and-their-sandboxing" title="Permalink to this headline">¶</a></h4>
<p>AppImages based on <a class="reference external" href="https://www.electron.build/">Electron</a> require the kernel to be configured in a certain way to allow for its sandboxing to work as intended (specifically, the kernel needs to be allowed to provide “unprivileged namespaces”). Many distributions come with this configured out of the box (like <a class="reference external" href="https://ubuntu.com">Ubuntu</a> for instance), but some do not (for example <a class="reference external" href="https://debian.org">Debian</a>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please note that the AppImage team does not provide any guarantees that enabling this feature is secure and safe. If in doubt, you need to contact your distribution first. If they enable those securely by default, all users can benefit from this feature.</p>
</div>
<div class="section" id="check-if-kernel-is-configured-correctly-already">
<h5>Check if kernel is configured correctly already<a class="headerlink" href="#check-if-kernel-is-configured-correctly-already" title="Permalink to this headline">¶</a></h5>
<p>To check if your distribution has unprivileged namespaces enabled, please run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">sysctl</span> <span class="n">kernel</span><span class="o">.</span><span class="n">unprivileged_userns_clone</span>
<span class="n">kernel</span><span class="o">.</span><span class="n">unprivileged_userns_clone</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">1</span></code> means that the unprivileged namespaces are enabled already, and you do not have to take any action.
A <code class="docutils literal notranslate"><span class="pre">0</span></code> indicates that the feature is available, but not enabled at the moment. Please see the following sections on how to enable it.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The command does not need to be run as <code class="docutils literal notranslate"><span class="pre">root</span></code>.</p>
</div>
</div>
<div class="section" id="configure-unprivileged-sandboxes">
<span id="ref-electron-sandboxing-configure-temporarily"></span><h5>Configure unprivileged sandboxes<a class="headerlink" href="#configure-unprivileged-sandboxes" title="Permalink to this headline">¶</a></h5>
<p>To temporarily enable unprivileged namespaces, you can run this command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">sysctl</span> <span class="o">-</span><span class="n">w</span> <span class="n">kernel</span><span class="o">.</span><span class="n">unprivileged_userns_clone</span><span class="o">=</span><span class="mi">1</span>
</pre></div>
</div>
<p>You can run the same command, swapping the <code class="docutils literal notranslate"><span class="pre">1</span></code> for a <code class="docutils literal notranslate"><span class="pre">0</span></code>, to disable this again.</p>
<p>To permanently enable the feature, it is recommended to create a new file in <code class="docutils literal notranslate"><span class="pre">/etc/sysctl.d/</span></code>. For your convenience, we have prepared the following command which creates the file on the fly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">echo</span> <span class="n">kernel</span><span class="o">.</span><span class="n">unprivileged_userns_clone</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">sudo</span> <span class="n">tee</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">sysctl</span><span class="o">.</span><span class="n">d</span><span class="o">/</span><span class="mi">00</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">userns</span><span class="o">.</span><span class="n">conf</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This command will take effect only on the next reboot. To change this on a running system, please refer to the <a class="reference internal" href="#ref-electron-sandboxing-configure-temporarily"><span class="std std-ref">previous section</span></a>.</p>
</div>
</div>
<div class="section" id="more-information-on-unprivileged-namespaces">
<h5>More information on unprivileged namespaces<a class="headerlink" href="#more-information-on-unprivileged-namespaces" title="Permalink to this headline">¶</a></h5>
<p>For more information on unprivileged namespaces, please see <a class="reference external" href="https://lwn.net/Articles/673597/">https://lwn.net/Articles/673597/</a>.</p>
</div>
</div>
</div>
</div>
</div>
<span id="document-packaging-guide/index"></span><div class="section" id="packaging-guide">
<span id="ref-packaging-guide"></span><h2>Packaging Guide<a class="headerlink" href="#packaging-guide" title="Permalink to this headline">¶</a></h2>
<p>This chapter shows application developers how to produce AppImages, how to make them updateable and how to digitally sign them.</p>
<div class="toctree-wrapper compound">
<span id="document-packaging-guide/introduction"></span><div class="section" id="introduction-to-packaging">
<h3>Introduction to Packaging<a class="headerlink" href="#introduction-to-packaging" title="Permalink to this headline">¶</a></h3>
<p>So you decided to make an AppImage or two? Great! Or did you just come here to get some insights into how AppImages can be built? Let’s have a look.</p>
<p>There are many different approaches how to build AppImages. Often, packaging an AppImage correctly depends on the application that you’re trying to put into one, the so-called <em>payload</em>. Different programming languages (or, rather, different application types (i.e., native binaries, scripts, bytecode, etc.)) require different methods.</p>
<p>All application bundling attempts have one thing in common: the “input format” which is then turned into an AppImage using <a class="reference internal" href="index.html#ref-appimagetool"><span class="std std-ref">appimagetool</span></a>. This input format is called AppDir, and is described in the <a class="reference internal" href="index.html#ref-appdir-specification"><span class="std std-ref">AppDir specification</span></a>.</p>
<p>In a nutshell: packaging AppImages is building an AppDir. This AppDir is then simply turned into an AppImage. But if your AppDir is not built correctly, the AppImage won’t work.</p>
<p>Of course, you’re not left alone with this challenge. There are official as well as unofficial tools that allow you to create working AppDirs. These are described in the following sections. Just pick the one you think suits your needs, and start making AppImages.</p>
</div>
<span id="document-packaging-guide/overview"></span><div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>There are different ways to create AppImages. The following section gives you an overview of which ways are available, their advantages and disadvantages, and where to find more information.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#packaging-from-source" id="id2">Packaging from source</a></p></li>
<li><p><a class="reference internal" href="#converting-existing-binary-packages" id="id3">Converting existing binary packages</a></p></li>
<li><p><a class="reference internal" href="#using-the-open-build-service" id="id4">Using the Open Build Service</a></p></li>
<li><p><a class="reference internal" href="#using-appimage-builder" id="id5">Using appimage-builder</a></p></li>
<li><p><a class="reference internal" href="#manually-creating-an-appdir" id="id6">Manually creating an AppDir</a></p></li>
</ul>
</div>
<div class="section" id="packaging-from-source">
<h4><a class="toc-backref" href="#id2">Packaging from source</a><a class="headerlink" href="#packaging-from-source" title="Permalink to this headline">¶</a></h4>
<p>The recommended approach is to package software from source. Ideally, upstream application authors take over maintenance of AppImages, and provide them on their release pages.</p>
<p>To learn more about how packaging from source works, please refer to <a class="reference internal" href="index.html#ref-packaging-from-source"><span class="std std-ref">Packaging from source</span></a>.</p>
<p>The process of packaging from source can and should be automated. CI systems like Travis CI can help with that.</p>
<div class="section" id="automated-continuous-builds-on-travis-ci">
<h5>Automated continuous builds on Travis CI<a class="headerlink" href="#automated-continuous-builds-on-travis-ci" title="Permalink to this headline">¶</a></h5>
<p>This option might be the easiest if you already have continuous builds on Travis CI in place. In this case, you can write a small scriptfile and in many cases are done with the AppImage generation.</p>
<p>More information on using Travis CI for making AppImages can be found in <a class="reference internal" href="index.html#ref-travis-ci"><span class="std std-ref">Bundling your Travis CI builds as AppImages</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>There are a lot of examples on GitHub that can be found using the <a class="reference external" href="https://github.com/search?utf8=%E2%9C%93&amp;q=%22Package+the+binaries+built+on+Travis-CI+as+an+AppImage%22&amp;type=Code&amp;ref=searchresults">GitHub search</a>.</p>
</div>
</div>
<div class="section" id="using-electron-builder">
<h5>Using electron-builder<a class="headerlink" href="#using-electron-builder" title="Permalink to this headline">¶</a></h5>
<p>For <a class="reference external" href="https://electronjs.org/">Electron</a> based applications, a tool called <a class="reference external" href="https://www.electron.build/">electron-builder</a> can be used to create AppImages.</p>
<p>With electron-builder, making AppImages is as simple as defining <code class="docutils literal notranslate"><span class="pre">AppImage</span></code> as a target for Linux (default in the latest version of electron-builder). This should yield usable results for most applications.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>More information can be found in the <a class="reference external" href="https://www.electron.build/configuration/appimage.html">documentation on AppImage</a> and <a class="reference external" href="https://www.electron.build/index.html#pack-only-in-a-distributable-format">the documentation on distributable formats</a> in the <a class="reference external" href="https://www.electron.build">electron-builder manual</a>.</p>
<p>There are a lot of examples on GitHub that can be found using the <a class="reference external" href="https://github.com/search?utf8=%E2%9C%93&amp;q=electron-builder+linux+target+appimage&amp;type=Code&amp;ref=searchresults">GitHub search</a>.</p>
</div>
</div>
</div>
<div class="section" id="converting-existing-binary-packages">
<h4><a class="toc-backref" href="#id3">Converting existing binary packages</a><a class="headerlink" href="#converting-existing-binary-packages" title="Permalink to this headline">¶</a></h4>
<p>This option might be the easiest if you already have up-to-date packages in place, ideally a PPA for the oldest still-supported Ubuntu LTS release (xenial as of 2019, see <a class="reference external" href="https://en.wikipedia.org/wiki/Ubuntu#Releases">https://en.wikipedia.org/wiki/Ubuntu#Releases</a> for up to date information) or earlier or a debian repository for oldstable. In this case, you can write a small <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> recipe and in many cases are done with the package to AppImage conversion. See <span class="xref std std-ref">convert-existing-binary-packages</span> for more information.</p>
</div>
<div class="section" id="using-the-open-build-service">
<h4><a class="toc-backref" href="#id4">Using the Open Build Service</a><a class="headerlink" href="#using-the-open-build-service" title="Permalink to this headline">¶</a></h4>
<p>This option is recommended for open source projects because it allows you to leverage the existing Open Build Service infrastructure, security and license compliance processes.</p>
<p>More information on using OBS for making AppImages can be found in <a class="reference internal" href="index.html#ref-obs"><span class="std std-ref">Using the Open Build Service</span></a>.</p>
</div>
<div class="section" id="using-appimage-builder">
<h4><a class="toc-backref" href="#id5">Using appimage-builder</a><a class="headerlink" href="#using-appimage-builder" title="Permalink to this headline">¶</a></h4>
<p>appimage-builder is a novel tool for creating AppImages. It uses the system package manager to resolve the
application dependencies and creates a complete bundle. It can be used to pack almost any kinds of applications
including those made using: C/C++, Python, and Java.</p>
<p>This tool removes the limitations of requiring an <em>old system</em> to compile the binaries. It can be used to
pack an application from sources or to turn an existing Debian package into an AppImage.</p>
<p>For more information about appimage-builder please visit: <a class="reference external" href="https://appimage-builder.readthedocs.io">https://appimage-builder.readthedocs.io</a></p>
</div>
<div class="section" id="manually-creating-an-appdir">
<h4><a class="toc-backref" href="#id6">Manually creating an AppDir</a><a class="headerlink" href="#manually-creating-an-appdir" title="Permalink to this headline">¶</a></h4>
<p>Create an AppDir manually, then turn it into an AppImage. Please note that this method should only be your last resort, as the other methods are much more convenient in most cases. Manually creating an AppDir is explained mainly to illustrate how things work under the hood.</p>
<p>See <a class="reference internal" href="index.html#ref-manual"><span class="std std-ref">Manual packaging</span></a> for more information.</p>
</div>
</div>
<span id="document-packaging-guide/from-source/index"></span><div class="section" id="packaging-from-source">
<span id="ref-packaging-from-source"></span><span id="ref-from-source"></span><h3>Packaging from source<a class="headerlink" href="#packaging-from-source" title="Permalink to this headline">¶</a></h3>
<p>This section contains guides how AppImages can be created from source code. It shows a few tricks how functionality of widely used build tools like e.g., CMake, can be re-used to reduce the amount of code required for building AppImages. Also, it is shown how externally maintained tools with support for building AppImages can be used.</p>
<div class="toctree-wrapper compound">
<span id="document-packaging-guide/from-source/native-binaries"></span><div class="section" id="packaging-native-binaries">
<span id="ref-packaging-native-binaries"></span><h4>Packaging native binaries<a class="headerlink" href="#packaging-native-binaries" title="Permalink to this headline">¶</a></h4>
<p>The most easy packaging methods are available for <em>native binaries</em>, like e.g., produced when compiling C++ or C code. Native binaries have a well defined and reliable behavior to find their runtime dependencies, the so-called shared libraries. These are the primary dependencies you will have to ship with your application. Of course, some applications might require additional resources, e.g., icon files. Also, some applications try to load libraries dynamically during the runtime. But for now, let’s assume we have a basic binary application (this is the most common type).</p>
<p>The AppImage team provides tools that simplify the packaging process significantly. These tools are semi-automatic, and ship with various features needed to bundle said shared library dependencies correctly. The one we are going to use in this guide is <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy">linuxdeploy</a>.</p>
<p>linuxdeploy is an AppDir maintenance tool. Its primary focus is on AppDirs, AppImage is just one possible output format. It features a plugin system for greater flexibility in use. Plugins can either bundle additional resources for e.g., frameworks such as <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy-plugin-qt">Qt</a>, but are also used to provide output generators, e.g., for <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy-plugin-appimage">AppImages</a>.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#packaging-from-source" id="id4">Packaging from source</a></p>
<ul>
<li><p><a class="reference internal" href="#using-the-build-system-to-build-the-basic-appdir" id="id5">Using the build system to build the basic AppDir</a></p></li>
<li><p><a class="reference internal" href="#using-linuxdeploy-for-building-appimages" id="id6">Using linuxdeploy for building AppImages</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#packaging-existing-binaries-or-manually-packaging-everything" id="id7">Packaging existing binaries (or: manually packaging everything)</a></p></li>
<li><p><a class="reference internal" href="#bundling-additional-resources-using-linuxdeploy-plugins" id="id8">Bundling additional resources using linuxdeploy plugins</a></p></li>
<li><p><a class="reference internal" href="#build-appimages-from-appdir-using-linuxdeploy" id="id9">Build AppImages from AppDir using linuxdeploy</a></p></li>
<li><p><a class="reference internal" href="#examples" id="id10">Examples</a></p>
<ul>
<li><p><a class="reference internal" href="#qtquickapp" id="id11">QtQuickApp</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="packaging-from-source">
<h5><a class="toc-backref" href="#id4">Packaging from source</a><a class="headerlink" href="#packaging-from-source" title="Permalink to this headline">¶</a></h5>
<p>Building applications from source and packaging them as AppImages is the most common scenario. In this section, it is described how apps that were built from source can be packaged into AppDirs, from which AppImages are being generated.</p>
<div class="section" id="using-the-build-system-to-build-the-basic-appdir">
<span id="ref-make-install-workflow"></span><h6><a class="toc-backref" href="#id5">Using the build system to build the basic AppDir</a><a class="headerlink" href="#using-the-build-system-to-build-the-basic-appdir" title="Permalink to this headline">¶</a></h6>
<p>If you use a modern build system (such as for instance <a class="reference internal" href="#cmake">CMake</a> or <a class="reference internal" href="#qmake">qmake</a>), you can use the provided <cite>make install</cite> commands to create an AppDir-like directory that can be used with linuxdeploy.</p>
<p>As install configurations usually install all binaries, libraries, resources etc. in a way defined by the application author, this method provides a very easy and fast way to set up the basic AppDir.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Of course, the application authors need to set up install configurations in their buildsystem, otherwise this method is not usable. Many applications have working install configurations, though. If not, you should ask the authors to add the relevant code to their build system.</p>
</div>
<div class="section" id="cmake">
<h7>CMake<a class="headerlink" href="#cmake" title="Permalink to this headline">¶</a></h7>
<p>CMake provides an additional parameter to configure where the files are installed when running <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code> called <code class="code docutils literal notranslate"><span class="pre">DESTDIR</span></code>. If <code class="code docutils literal notranslate"><span class="pre">DESTDIR</span></code> is specified, CMake will “install” the files into the given directory instead of the filesystem root (<code class="code docutils literal notranslate"><span class="pre">/</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By default, CMake sets an internal variable called <code class="code docutils literal notranslate"><span class="pre">CMAKE_INSTALL_PREFIX</span></code> to a path other than <code class="docutils literal notranslate"><span class="pre">/usr</span></code> to prevent users calling e.g., <code class="code docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">make</span> <span class="pre">install</span></code> from damaging their system. The variable must explicitly be set to <code class="docutils literal notranslate"><span class="pre">/usr</span></code> therefore.</p>
</div>
<p>Here’s an example how to use this method:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># fetch sources (you could as well use a tarball etc.)</span>
&gt; git clone https://github.com/linuxdeploy/QtQuickApp.git
&gt; <span class="nb">cd</span> QtQuickApp

<span class="c1"># build out of source</span>
&gt; mkdir build
&gt; <span class="nb">cd</span> build

<span class="c1"># configure build system</span>
<span class="c1"># the flags below are the bare minimum that is needed, the app might define additional variables that might have to be set</span>
&gt; cmake .. -DCMAKE_INSTALL_PREFIX<span class="o">=</span>/usr

<span class="c1"># build the application on all CPU cores</span>
&gt; make -j<span class="k">$(</span>nproc<span class="k">)</span>

<span class="c1"># now &quot;install&quot; resources into future AppDir</span>
&gt; make install <span class="nv">DESTDIR</span><span class="o">=</span>AppDir
</pre></div>
</div>
<p>Now, ideally all the binaries and libraries the app needs are installed into a new directory called <code class="code docutils literal notranslate"><span class="pre">AppDir</span></code> in your build directory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The quality of the install configurations will vary from app to app. Please don’t be surprised if the application is installed partially only. If the command doesn’t exist at all, please fall back to bundling manually, which is described below.</p>
</div>
</div>
<div class="section" id="qmake">
<h7>qmake<a class="headerlink" href="#qmake" title="Permalink to this headline">¶</a></h7>
<p>Qt’s <a class="reference internal" href="#qmake">qmake</a> also provides a variable to change the “target” of <code class="code docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code> calls called <code class="code docutils literal notranslate"><span class="pre">INSTALL_ROOT</span></code>. The qmake-based method is very similar to the CMake one. There’s just one major difference: qmake does install into <code class="docutils literal notranslate"><span class="pre">/usr</span></code> by default already.</p>
<p>Preparing a basic application is very simple, as the following example illustrates:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># get the source code</span>
&gt; git clone https://github.com/linuxdeploy/QtQuickApp.git
&gt; <span class="nb">cd</span> QtQuickApp

<span class="c1"># create out-of-source build dir and run qmake to prepare the Makefile</span>
&gt; mkdir build
&gt; <span class="nb">cd</span> build
&gt; qmake ..

<span class="c1"># build the application on all CPU cores</span>
&gt; make -j<span class="k">$(</span>nproc<span class="k">)</span>

<span class="c1"># use make install to prepare the AppDir</span>
&gt; make install <span class="nv">INSTALL_ROOT</span><span class="o">=</span>AppDir
</pre></div>
</div>
<p>Now, you have a new directory <code class="docutils literal notranslate"><span class="pre">AppDir</span></code> which ideally contains all the binaries, shared libraries etc., just like after finishing the CMake method.</p>
</div>
</div>
<div class="section" id="using-linuxdeploy-for-building-appimages">
<h6><a class="toc-backref" href="#id6">Using linuxdeploy for building AppImages</a><a class="headerlink" href="#using-linuxdeploy-for-building-appimages" title="Permalink to this headline">¶</a></h6>
<p>Now that we have the basic AppDir, we need to bundle dependencies into it to make the AppDir self-contained in preparation to make an AppImage from it. The following guide shows how <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy">linuxdeploy</a> is used for this purpose.</p>
<p>linuxdeploy describes itself as an <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy/blob/master/README.md">“AppDir maintenance tool”</a>. Its primary focus is on AppDirs, and it uses plugins to create output formats such as AppImages.</p>
<p>The following section describes how it can be used to deploy dependencies of applications into an AppDir that was created using the methods described in the <a class="reference internal" href="#ref-make-install-workflow"><span class="std std-ref">previous section</span></a>, and shows how this AppDir can eventually be packaged as an AppImage.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Please see <a class="reference internal" href="index.html#ref-linuxdeploy"><span class="std std-ref">linuxdeploy user guide</span></a> for more information on how to use linuxdeploy.</p>
</div>
<div class="section" id="bundling-resources-into-the-appdir">
<h7>Bundling resources into the AppDir<a class="headerlink" href="#bundling-resources-into-the-appdir" title="Permalink to this headline">¶</a></h7>
<p>Start by downloading linuxdeploy. The recommended way to get it is to use the AppImages provided on the <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy/releases/">GitHub release page</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>At the moment, AppImages are provided for <code class="code docutils literal notranslate"><span class="pre">x86/i386</span></code> and <code class="code docutils literal notranslate"><span class="pre">x86_64/amd64</span></code> architectures, as other platforms cannot be targeted properly on the build service. The tool itself should support all major platforms, including ARM. You can compile linuxdeploy yourself to test it. Contributions adding new platforms welcome!</p>
</div>
<p>After downloading the AppImage, you have to make it executable, as usual. Then, you can first run linuxdeploy on your AppDir:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt; ./linuxdeploy-x86_64.AppImage --appdir AppDir
</pre></div>
</div>
<p>This creates <code class="code docutils literal notranslate"><span class="pre">AppDir</span></code> if it doesn’t exist yet. Inside <code class="code docutils literal notranslate"><span class="pre">AppDir</span></code> some basic directory structure is created that isn’t necessarily required, but might be handy when adding resources manually to the AppImage.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>linuxdeploy supports an iterative workflow, i.e., you run it, and it will start to bundle resources. If there is a problem, it will show a detailed error message, and exit with an error code. You can then fix the issue, and call it again to try again. See <span class="xref std std-ref">ref-linuxdeploy-iterative-workflow</span> for more information.</p>
</div>
<p>If your application has installed itself properly, it should have installed a desktop file and an icon as well. The desktop file is used for <a class="reference internal" href="index.html#ref-desktop-integration"><span class="std std-ref">AppImage desktop integration</span></a>, and since desktop files require icons, an icon is always required, too.</p>
<p>Example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># get linuxdeploy&#39;s AppImage</span>
&gt; wget https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
&gt; chmod +x linuxdeploy-x86_64.AppImage

<span class="c1"># run linuxdeploy and generate an AppDir</span>
&gt; ./linuxdeploy-x86_64.AppImage --appdir AppDir
</pre></div>
</div>
<p>You can bundle additional resources such as icon files, executable and desktop files using the respective flags described in the <code class="docutils literal notranslate"><span class="pre">--help</span></code> text or on linuxdeploy’s <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy">homepage</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Desktop file and icon are used for so-called <a class="reference internal" href="index.html#ref-desktop-integration"><span class="std std-ref">desktop integration</span></a>. If your build system didn’t install such files into the right location, you can have linuxdeploy put your own files into the right places. Please see <span class="xref std std-ref">linuxdeploy-bundle-desktop-files-icons</span> for more information.</p>
</div>
</div>
</div>
</div>
<div class="section" id="packaging-existing-binaries-or-manually-packaging-everything">
<span id="ref-package-existing-binaries"></span><h5><a class="toc-backref" href="#id7">Packaging existing binaries (or: manually packaging everything)</a><a class="headerlink" href="#packaging-existing-binaries-or-manually-packaging-everything" title="Permalink to this headline">¶</a></h5>
<p>Packaging existing binaries is very simple as well. As the existing binaries don’t provide facilities to <a class="reference internal" href="#ref-make-install-workflow"><span class="std std-ref">create a basic AppDir with the build system</span></a>, you have to package everything into the right place manually.</p>
<p>Luckily, linuxdeploy supports such a workflow as well. It provides functionalities to automatically put the most common resources an application might use (such as binaries, libraries, desktop files and icons) into the right places without having the user to create any sort of structure or know where to put files. This is described in <a class="reference internal" href="index.html#linuxdeploy-package-manually"><span class="std std-ref">Packaging binaries and other resources manually</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Many applications require more resources during runtime than just the binaries and libraries. Often, they require graphics for drawing a UI, or other files that are normally in a “known good location” on the system. These resources should be bundled into the AppImage as well to make sure the AppImage is as standalone as possible. However, linuxdeploy cannot know which files to bundle.</p>
<p>Please consult the applications’ documentation (e.g., homepage or man pages) to see what kinds of resources must be put into the AppImage. This can involve some trial-and-error, as you need to <span class="xref std std-ref">test your AppImages on different systems</span> to find possible errors.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In order to be packaged as AppImages, applications must load the resources relative to their main binary, and not from a hardcoded path (usually <code class="docutils literal notranslate"><span class="pre">/usr/...</span></code>). This is called <span class="xref std std-ref">relocatability</span>.</p>
<p>If your app doesn’t load resources from the AppImage, but e.g., shows errors it couldn’t find resources, it is most likely not relocatable. In this case, you must ask the author of the application to make it relocatable. Many modern frameworks such as Qt even provide functionality to implement this easily. In some cases, there’s also flags you can specify when building from source to make applications relocatable.</p>
</div>
</div>
<div class="section" id="bundling-additional-resources-using-linuxdeploy-plugins">
<h5><a class="toc-backref" href="#id8">Bundling additional resources using linuxdeploy plugins</a><a class="headerlink" href="#bundling-additional-resources-using-linuxdeploy-plugins" title="Permalink to this headline">¶</a></h5>
<p>As mentioned previously, linuxdeploy provides a plugin system. So-called “input” plugins can be used to bundle additional resources, such as Qt plugins, translations, etc.</p>
<p>Please see <a class="reference internal" href="index.html#linuxdeploy-input-plugins"><span class="std std-ref">Using input plugins</span></a> for more information.</p>
</div>
<div class="section" id="build-appimages-from-appdir-using-linuxdeploy">
<span id="linuxdeploy-plugin-appimage-user-guide"></span><h5><a class="toc-backref" href="#id9">Build AppImages from AppDir using linuxdeploy</a><a class="headerlink" href="#build-appimages-from-appdir-using-linuxdeploy" title="Permalink to this headline">¶</a></h5>
<p>As mentioned previously, linuxdeploy uses plugins to create actual output files from AppDirs. For AppImages, there’s <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy-plugin-appimage">linuxdeploy-plugin-appimage</a>.</p>
<p>To create AppImages, just add <code class="docutils literal notranslate"><span class="pre">--output</span> <span class="pre">appimage</span></code> to your linuxdeploy call to enable the plugin. An AppImage will be created using <a class="reference internal" href="index.html#ref-appimagetool"><span class="std std-ref">appimagetool</span></a>.</p>
<p>Minimal example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt; ./linuxdeploy-x86_64.AppImage --appdir AppDir --output appimage
</pre></div>
</div>
<p>As most plugins, linuxdeploy-plugin-appimage provides some environment variables to enable additional functionality, such as:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SIGN=1</span></code></dt><dd><p>Sign AppImage. See <span class="xref std std-ref">ref-signing-appimages</span> for more information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UPDATE_INFORMATION=zsync|...</span></code></dt><dd><p>Add update information to the AppImage, and generate a <code class="docutils literal notranslate"><span class="pre">.zsync</span></code> file.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>More information on the environment variables can be found in the <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy-plugin-appimage/blob/master/README.md">README</a>, including a complete (and up to date) list of supported environment variables.</p>
</div>
</div>
<div class="section" id="examples">
<h5><a class="toc-backref" href="#id10">Examples</a><a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h5>
<p>In this section, some examples how linuxdeploy can be used are shown.</p>
<div class="section" id="qtquickapp">
<h6><a class="toc-backref" href="#id11">QtQuickApp</a><a class="headerlink" href="#qtquickapp" title="Permalink to this headline">¶</a></h6>
<p>This section contains a few example scripts that showcase how AppImages can be built for <a class="reference external" href="https://github.com/linuxdeploy/QtQuickApp">QtQuickApp</a>, a basic demonstration app based on QtQuick, using some QML internally. It can be built using both CMake and qmake. We use it to show some example scripts how AppImages can be built for it, using the methods introduced in this guide.</p>
<div class="section" id="using-qmake-and-make-install">
<h7>Using qmake and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code><a class="headerlink" href="#using-qmake-and-make-install" title="Permalink to this headline">¶</a></h7>
<p>The following script might be used to create AppImages for QtQuickApp, using qmake and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code> strategy.</p>
<div class="literal-block-wrapper docutils container" id="bundle-qtquickapp">
<div class="code-block-caption"><span class="caption-text"><code class="code docutils literal notranslate"><span class="pre">travis/build-with-qmake.sh</span></code></span><a class="headerlink" href="#bundle-qtquickapp" title="Permalink to this code">¶</a></div>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#! /bin/bash</span>

<span class="nb">set</span> -x
<span class="nb">set</span> -e

<span class="c1"># building in temporary directory to keep system clean</span>
<span class="c1"># use RAM disk if possible (as in: not building on CI system like Travis, and RAM disk is available)</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$CI</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> -d /dev/shm <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">TEMP_BASE</span><span class="o">=</span>/dev/shm
<span class="k">else</span>
    <span class="nv">TEMP_BASE</span><span class="o">=</span>/tmp
<span class="k">fi</span>

<span class="nv">BUILD_DIR</span><span class="o">=</span><span class="k">$(</span>mktemp -d -p <span class="s2">&quot;</span><span class="nv">$TEMP_BASE</span><span class="s2">&quot;</span> appimage-build-XXXXXX<span class="k">)</span>

<span class="c1"># make sure to clean up build dir, even if errors occur</span>
cleanup <span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span> -d <span class="s2">&quot;</span><span class="nv">$BUILD_DIR</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        rm -rf <span class="s2">&quot;</span><span class="nv">$BUILD_DIR</span><span class="s2">&quot;</span>
    <span class="k">fi</span>
<span class="o">}</span>
<span class="nb">trap</span> cleanup EXIT

<span class="c1"># store repo root as variable</span>
<span class="nv">REPO_ROOT</span><span class="o">=</span><span class="k">$(</span>readlink -f <span class="k">$(</span>dirname <span class="k">$(</span>dirname <span class="nv">$0</span><span class="k">)))</span>
<span class="nv">OLD_CWD</span><span class="o">=</span><span class="k">$(</span>readlink -f .<span class="k">)</span>

<span class="c1"># switch to build dir</span>
<span class="nb">pushd</span> <span class="s2">&quot;</span><span class="nv">$BUILD_DIR</span><span class="s2">&quot;</span>

<span class="c1"># configure build files with qmake</span>
<span class="c1"># we need to explicitly set the install prefix, as CMake&#39;s default is /usr/local for some reason...</span>
qmake <span class="s2">&quot;</span><span class="nv">$REPO_ROOT</span><span class="s2">&quot;</span>

<span class="c1"># build project and install files into AppDir</span>
make -j<span class="k">$(</span>nproc<span class="k">)</span>
make install <span class="nv">INSTALL_ROOT</span><span class="o">=</span>AppDir

<span class="c1"># now, build AppImage using linuxdeploy and linuxdeploy-plugin-qt</span>
<span class="c1"># download linuxdeploy and its Qt plugin</span>
wget https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
wget https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage

<span class="c1"># make them executable</span>
chmod +x linuxdeploy*.AppImage

<span class="c1"># make sure Qt plugin finds QML sources so it can deploy the imported files</span>
<span class="nb">export</span> <span class="nv">QML_SOURCES_PATHS</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$REPO_ROOT</span><span class="s2">&quot;</span>/src

<span class="c1"># QtQuickApp does support &quot;make install&quot;, but we don&#39;t use it because we want to show the manual packaging approach in this example</span>
<span class="c1"># initialize AppDir, bundle shared libraries, add desktop file and icon, use Qt plugin to bundle additional resources, and build AppImage, all in one command</span>
./linuxdeploy-x86_64.AppImage --appdir AppDir -e QtQuickApp -i <span class="s2">&quot;</span><span class="nv">$REPO_ROOT</span><span class="s2">&quot;</span>/resources/qtquickapp.png -d <span class="s2">&quot;</span><span class="nv">$REPO_ROOT</span><span class="s2">&quot;</span>/resources/qtquickapp.desktop --plugin qt --output appimage

<span class="c1"># move built AppImage back into original CWD</span>
mv QtQuickApp*.AppImage <span class="s2">&quot;</span><span class="nv">$OLD_CWD</span><span class="s2">&quot;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We’re using a separate bash script that runs in an isolated, temporary directory to prevent modifications to the existing source code or the system.</p>
<p>Many examples “hack” those instructions directly into their CI configuration, e.g., <code class="docutils literal notranslate"><span class="pre">.travis.yml</span></code>. This approach has many problems, most notably that it’s impossible to test those scripts locally. By extracting the whole process into a script, it becomes quite simple to test the build script locally as well as run it in the CI system.</p>
<p>An example <code class="code docutils literal notranslate"><span class="pre">.travis.yml</span></code> is included in a later section, showing how the script can be run on Travis CI. It’s quite generic, you should be able to copy it without having to make too many modifications.</p>
</div>
</div>
<div class="section" id="using-cmake-and-make-install">
<h7>Using CMake and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code><a class="headerlink" href="#using-cmake-and-make-install" title="Permalink to this headline">¶</a></h7>
<p>The following script might be used to create AppImages for QtQuickApp, using qmake and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code> strategy. It is effectively the same script as the <code class="docutils literal notranslate"><span class="pre">qmake</span></code> one, but uses CMake instead of qmake to build the binaries and install the data into the AppDir.</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text"><code class="code docutils literal notranslate"><span class="pre">travis/build-with-cmake.sh</span></code></span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#! /bin/bash</span>

<span class="nb">set</span> -x
<span class="nb">set</span> -e

<span class="c1"># building in temporary directory to keep system clean</span>
<span class="c1"># use RAM disk if possible (as in: not building on CI system like Travis, and RAM disk is available)</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$CI</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> -d /dev/shm <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">TEMP_BASE</span><span class="o">=</span>/dev/shm
<span class="k">else</span>
    <span class="nv">TEMP_BASE</span><span class="o">=</span>/tmp
<span class="k">fi</span>

<span class="nv">BUILD_DIR</span><span class="o">=</span><span class="k">$(</span>mktemp -d -p <span class="s2">&quot;</span><span class="nv">$TEMP_BASE</span><span class="s2">&quot;</span> appimage-build-XXXXXX<span class="k">)</span>

<span class="c1"># make sure to clean up build dir, even if errors occur</span>
cleanup <span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span> -d <span class="s2">&quot;</span><span class="nv">$BUILD_DIR</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        rm -rf <span class="s2">&quot;</span><span class="nv">$BUILD_DIR</span><span class="s2">&quot;</span>
    <span class="k">fi</span>
<span class="o">}</span>
<span class="nb">trap</span> cleanup EXIT

<span class="c1"># store repo root as variable</span>
<span class="nv">REPO_ROOT</span><span class="o">=</span><span class="k">$(</span>readlink -f <span class="k">$(</span>dirname <span class="k">$(</span>dirname <span class="nv">$0</span><span class="k">)))</span>
<span class="nv">OLD_CWD</span><span class="o">=</span><span class="k">$(</span>readlink -f .<span class="k">)</span>

<span class="c1"># switch to build dir</span>
<span class="nb">pushd</span> <span class="s2">&quot;</span><span class="nv">$BUILD_DIR</span><span class="s2">&quot;</span>

<span class="c1"># configure build files with CMake</span>
<span class="c1"># we need to explicitly set the install prefix, as CMake&#39;s default is /usr/local for some reason...</span>
cmake <span class="s2">&quot;</span><span class="nv">$REPO_ROOT</span><span class="s2">&quot;</span> -DCMAKE_INSTALL_PREFIX<span class="o">=</span>/usr

<span class="c1"># build project and install files into AppDir</span>
make -j<span class="k">$(</span>nproc<span class="k">)</span>
make install <span class="nv">DESTDIR</span><span class="o">=</span>AppDir

<span class="c1"># now, build AppImage using linuxdeploy and linuxdeploy-plugin-qt</span>
<span class="c1"># download linuxdeploy and its Qt plugin</span>
wget https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
wget https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage

<span class="c1"># make them executable</span>
chmod +x linuxdeploy*.AppImage

<span class="c1"># make sure Qt plugin finds QML sources so it can deploy the imported files</span>
<span class="nb">export</span> <span class="nv">QML_SOURCES_PATHS</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$REPO_ROOT</span><span class="s2">&quot;</span>/src

<span class="c1"># initialize AppDir, bundle shared libraries for QtQuickApp, use Qt plugin to bundle additional resources, and build AppImage, all in one single command</span>
./linuxdeploy-x86_64.AppImage --appdir AppDir --plugin qt --output appimage

<span class="c1"># move built AppImage back into original CWD</span>
mv QtQuickApp*.AppImage <span class="s2">&quot;</span><span class="nv">$OLD_CWD</span><span class="s2">&quot;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="integrate-build-scripts-into-ci-systems">
<h7>Integrate build scripts into CI systems<a class="headerlink" href="#integrate-build-scripts-into-ci-systems" title="Permalink to this headline">¶</a></h7>
<div class="section" id="travis-ci">
<h8>Travis CI<a class="headerlink" href="#travis-ci" title="Permalink to this headline">¶</a></h8>
<p>The scripts introduced in the previous subsections will move the files back into the directory where they’re called. Therefore, the <code class="code docutils literal notranslate"><span class="pre">.travis.yml</span></code> and especially the <code class="code docutils literal notranslate"><span class="pre">script</span></code> file can be kept delightfully short:</p>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption"><span class="caption-text"><code class="code docutils literal notranslate"><span class="pre">.travis.yml</span></code></span><a class="headerlink" href="#id3" title="Permalink to this code">¶</a></div>
<div class="highlight-yaml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nt">language</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">cpp</span>
<span class="c1"># needed for installing packages with apt</span>
<span class="nt">sudo</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">required</span>

<span class="c1"># we use the Qt PPAs to have some more recent Qt versions that are compatible with Ubuntu trusty</span>
<span class="nt">before_install</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">sudo add-apt-repository ppa:beineri/opt-qt-5.10.1-trusty -y</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">sudo apt-get update</span>

<span class="c1"># install Qt from the PPA, and set up environment so that calls to Qt tools end up in the new Qt installation</span>
<span class="nt">install</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">sudo apt-get -y install qt510base qt510declarative</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">. /opt/qt*/bin/qt*-env.sh</span>

<span class="c1"># use CMake based build script shown in previous section</span>
<span class="nt">script</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">bash travis/build-with-cmake.sh</span>

<span class="c1"># OPTIONAL: uploading binaries using uploadtool</span>
<span class="c1"># see https://github.com/probonopd/uploadtool for more information</span>

<span class="nt">branches</span><span class="p">:</span>
  <span class="nt">except</span><span class="p">:</span>
    <span class="c1"># Do not build tags that we create when we upload to GitHub Releases</span>
    <span class="c1"># required for uploadtool</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">/^(?i:continuous)/</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Please see the <a class="reference internal" href="index.html#ref-travis-ci"><span class="std std-ref">Bundling your Travis CI builds as AppImages</span></a> section in the <a class="reference internal" href="index.html#ref-hosted-services"><span class="std std-ref">Hosted services</span></a> section for more information on Travis CI. It also contains a guide on <a class="reference internal" href="index.html#ref-uploadtool"><span class="std std-ref">uploadtool</span></a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<span id="document-packaging-guide/from-source/linuxdeploy-user-guide"></span><div class="section" id="linuxdeploy-user-guide">
<span id="ref-linuxdeploy"></span><h4>linuxdeploy user guide<a class="headerlink" href="#linuxdeploy-user-guide" title="Permalink to this headline">¶</a></h4>
<p>This page illustrates how linuxdeploy can be used.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<ul class="simple">
<li><p>Write introduction</p></li>
<li><p>Add references to examples in packaging guide</p></li>
</ul>
</div>
<p>linuxdeploy is capable of packaging dependencies of resources in an existing AppDir, or creating the AppDir from scratch, bundling resources into the right locations that the user passes to it.</p>
<p>linuxdeploy describes itself as an <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy/blob/master/README.md">“AppDir maintenance tool”</a>. Its primary focus is on AppDirs, and it uses plugins to create output formats such as AppImages.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#packaging-dependencies-of-files-in-an-existing-appdir" id="id5">Packaging dependencies of files in an existing AppDir</a></p></li>
<li><p><a class="reference internal" href="#packaging-binaries-and-other-resources-manually" id="id6">Packaging binaries and other resources manually</a></p></li>
<li><p><a class="reference internal" href="#plugin-system" id="id7">Plugin system</a></p></li>
</ul>
</div>
<div class="section" id="packaging-dependencies-of-files-in-an-existing-appdir">
<h5><a class="toc-backref" href="#id5">Packaging dependencies of files in an existing AppDir</a><a class="headerlink" href="#packaging-dependencies-of-files-in-an-existing-appdir" title="Permalink to this headline">¶</a></h5>
<p>Sometimes, the build system can be used to <span class="xref std std-ref">install resources into an AppDir-like structure</span>. If this so-called “install configuration” is feature complete, i.e., all the resources an AppImage needs (a binary, an icon and a desktop file), all linuxdeploy has to do is bundle the dependencies of these files.</p>
<p>This workflow is described in <a class="reference internal" href="index.html#ref-make-install-workflow"><span class="std std-ref">Using the build system to build the basic AppDir</span></a>.</p>
<p>In case some of the required files described above are <em>not</em> installed by <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code>, you can instruct linuxdeploy to bundle these resources manually. Please see the next section for more information.</p>
</div>
<div class="section" id="packaging-binaries-and-other-resources-manually">
<span id="linuxdeploy-package-manually"></span><h5><a class="toc-backref" href="#id6">Packaging binaries and other resources manually</a><a class="headerlink" href="#packaging-binaries-and-other-resources-manually" title="Permalink to this headline">¶</a></h5>
<p>Unlike the old tools, linuxdeploy doesn’t need any existing directory with files in the right positions, etc. Instead, it puts files specified via CLI parameters into the right positions. This makes bundling easier than ever before, as users don’t need to know where to put files any more.</p>
<p>linuxdeploy provides different flags to bundle different kinds of resources. Only resources whose destination can be calculated by linuxdeploy can be bundled this way. Additional resources applications need, which linuxdeploy can not know about, must be bundled by hand. However, the most common resources are covered by the parameters.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">--executable</span></code>/<code class="docutils literal notranslate"><span class="pre">-e</span></code></dt><dd><p>Bundle a native binary executable. Set up everything so that other libraries, executables etc. use this one instead of a system one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--library</span></code>/<code class="docutils literal notranslate"><span class="pre">-l</span></code></dt><dd><p>Bundle a shared library (<code class="code docutils literal notranslate"><span class="pre">.so</span></code> file) into the AppDir. Set up everything so that other libraries, executables etc. use this one instead of a system one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--desktop-file</span></code>/<code class="docutils literal notranslate"><span class="pre">-d</span></code></dt><dd><p>Bundle a desktop file into the AppDir. These are required for desktop integration, and there must always be at least one of them in the AppDir. Please see <span class="xref std std-ref">creating-desktop-file</span> for a guide how they can be created, and for best practices related to AppImages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--icon</span></code>/<code class="docutils literal notranslate"><span class="pre">-i</span></code></dt><dd><p>Bundle icon file. Supported are all formats which the <a class="reference external" href="https://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html">Icon Theme Specification</a> lists. linuxdeploy will automatically calculate the right output path, which depends on file format and resolution. You can specify multiple icons for multiple resolutions in the form of <code class="docutils literal notranslate"><span class="pre">&lt;resolution&gt;/&lt;app_name&gt;.&lt;ext&gt;</span></code>.</p>
</dd>
</dl>
<p>The following example illustrates how an existing binary can be bundled into an AppDir:</p>
</div>
<div class="section" id="plugin-system">
<span id="linuxdeploy-plugin-system"></span><h5><a class="toc-backref" href="#id7">Plugin system</a><a class="headerlink" href="#plugin-system" title="Permalink to this headline">¶</a></h5>
<p>linuxdeploy provides a flexible packaging system for both bundling additional resources that cannot be discovered automatically by linuxdeploy (i.e., plugins loaded during runtime using <code class="docutils literal notranslate"><span class="pre">dlopen()</span></code>, icon themes, etc.), and to convert the AppDir into an output format such as AppImage.</p>
<p>Plugins are automatically recognized by linuxdeploy. They are executable files (scripts, native binaries, etc.), which must be in one of the following locations:</p>
<blockquote>
<div><ul class="simple">
<li><p>in case the linuxdeploy AppImage is used: next to the AppImage</p></li>
<li><p>next to the linuxdeploy binary</p></li>
<li><p>in any of the directories in <code class="docutils literal notranslate"><span class="pre">$PATH</span></code></p></li>
</ul>
</div></blockquote>
<p>Therefore, when downloading additional plugins, just put them into one of these locations, and linuxdeploy can use them.</p>
<p>Plugins are standalone executable files. This means they must be made executable by the user before they can be used by linuxdeploy. On the other hand, this also allows for calling plugins manually.</p>
<p>The plugin system works by calling external executables, hence the only communication linuxdeploy can perform with plugins is via CLI parameters (communication via the <code class="docutils literal notranslate"><span class="pre">stdin</span></code>/<code class="docutils literal notranslate"><span class="pre">stdout</span></code> pipes would be a lot more complex to implement for both linuxdeploy and the plugin). Therefore, to influence plugin behavior, plugins may implement environment variables that the user can set <em>before</em> calling linuxdeploy. Examples how this works are shown in the following sections.</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">--list-plugins</span></code> flag to see what plugins are visible to linuxdeploy. This can come in handy when debugging plugin related issues. It lists the name of the plugin (i.e., what linuxdeploy refers to them as), the full path and the API level they implement.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Some plugins might be bundled in the linuxdeploy AppImage already for convenience. They’re likely out of date, but should be stable. In case there are any issues or you need to use a newer version, please download the latest version of the respective plugin, and put it next to the linuxdeploy AppImage. linuxdeploy prefers plugins next to the AppImage over bundled ones.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>More information on plugins can be found in the <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy/wiki/Plugin-system">plugin specification</a>.</p>
</div>
<div class="section" id="using-input-plugins">
<span id="linuxdeploy-input-plugins"></span><h6>Using input plugins<a class="headerlink" href="#using-input-plugins" title="Permalink to this headline">¶</a></h6>
<p>Input plugins can simply be switched on using the <code class="docutils literal notranslate"><span class="pre">--plugin</span></code> flag. For example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt; ./linuxdeploy-x86_64.AppImage --appdir AppDir &lt;...&gt; --plugin qt
</pre></div>
</div>
<p>This causes linuxdeploy to call a plugin called <code class="docutils literal notranslate"><span class="pre">qt</span></code>, if available.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An (incomplete) list of plugins can be found in the <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy/blob/master/README.md">linuxdeploy README</a> and in the <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy/wiki/">linuxdeploy wiki</a>.</p>
</div>
<div class="section" id="using-environment-variables-to-change-plugins-behavior">
<span id="linuxdeploy-input-plugins-environment-variables"></span><h7>Using environment variables to change plugins’ behavior<a class="headerlink" href="#using-environment-variables-to-change-plugins-behavior" title="Permalink to this headline">¶</a></h7>
<p>As mentioned previously, some plugins implement additional optional or mandatory parameters in the form of environment variables. These environment variables must be set <em>before</em> calling linuxdeploy.</p>
<p>For example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># set the environment variable</span>
&gt; <span class="nb">export</span> <span class="nv">FOOBAR_VAR</span><span class="o">=</span>example

<span class="c1"># call linuxdeploy with the respective plugin enabled</span>
&gt; ./linuxdeploy-x86_64.AppImage --appdir AppDir &lt;...&gt; --plugin foobar
</pre></div>
</div>
<p>Please refer to the plugins’ documentation to find a list of supported environment variables. If you can’t find any, there’s probably none.</p>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>Document existing input plugins’ environment variables</p>
</div>
</div>
</div>
<div class="section" id="creating-output-files">
<h6>Creating output files<a class="headerlink" href="#creating-output-files" title="Permalink to this headline">¶</a></h6>
<p>Similar to the input plugins, output plugins are enabled through a command line parameter. To avoid any possible confusion, a second parameter is used: <code class="docutils literal notranslate"><span class="pre">--output</span></code>.</p>
<p>Example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt; ./linuxdeploy-x86_64.AppImage &lt;...&gt; --output appimage
</pre></div>
</div>
<p>Most users are interested in generating AppImages, therefore the AppImage plugin is bundled in the official linuxdeploy AppImage. Please see the <a class="reference internal" href="index.html#linuxdeploy-plugin-appimage-user-guide"><span class="std std-ref">plugin’s user guide</span></a> for more information.</p>
<div class="section" id="id3">
<h7>Using environment variables to change plugins’ behavior<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h7>
<p>Users can use environment variables to <a class="reference internal" href="#linuxdeploy-input-plugins-environment-variables"><span class="std std-ref">change input plugins’ behavior</span></a> or enable additional features. Output plugins use the same method to provide similar functionality. Just set an environment variable <em>before</em> calling linuxdeploy with the respective plugin enabled. For example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># set environment variable to embed update information in an AppImage</span>
&gt; <span class="nb">export</span> <span class="nv">UPDATE_INFORMATION</span><span class="o">=</span><span class="s2">&quot;zsync|https://foo.bar/myappimage-latest.AppImage.zsync&quot;</span>

<span class="c1"># call linuxdeploy with the AppImage plugin enabled</span>
&gt; ./linuxdeploy-x86_64.AppImage --appdir AppDir &lt;...&gt; --output appimage
</pre></div>
</div>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>Document environment variables of existing output plugins</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<span id="document-packaging-guide/converting-binary-packages/index"></span><div class="section" id="converting-binary-packages">
<h3>Converting binary packages<a class="headerlink" href="#converting-binary-packages" title="Permalink to this headline">¶</a></h3>
<p>In some cases, it is possible to convert existing binary packages to AppImages. This section introduces tools for this purpose.</p>
<div class="toctree-wrapper compound">
<span id="document-packaging-guide/converting-binary-packages/pkg2appimage"></span><div class="section" id="pkg2appimage">
<span id="ref-pkg2appimage"></span><h4>pkg2appimage<a class="headerlink" href="#pkg2appimage" title="Permalink to this headline">¶</a></h4>
<p>If you already have existing binaries (either in archive or <code class="code docutils literal notranslate"><span class="pre">.deb</span></code> format or a ppa) then the recommended way to convert these to an AppImage is to write a <a class="reference external" href="https://github.com/AppImage/pkg2appimage/tree/master/recipes">.yml description file</a> and run it with <a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/master/pkg2appimage">pkg2appimage</a>.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id2">Introduction</a></p></li>
<li><p><a class="reference internal" href="#yml-files" id="id3"><code class="docutils literal notranslate"><span class="pre">.yml</span></code> files</a></p></li>
<li><p><a class="reference internal" href="#purpose-of-yml-files" id="id4">Purpose of <code class="docutils literal notranslate"><span class="pre">.yml</span></code> files</a></p></li>
<li><p><a class="reference internal" href="#general-anatomy-of-yml-files" id="id5">General anatomy of <code class="docutils literal notranslate"><span class="pre">.yml</span></code> files</a></p></li>
<li><p><a class="reference internal" href="#converting-python-applications-packaged-with-pip" id="id6">Converting Python applications packaged with pip</a></p></li>
</ul>
</div>
<div class="section" id="introduction">
<h5><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h5>
<p>To build an AppImage from a <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> description file, simply run:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>bash -ex ./pkg2appimage recipes/XXX.yml
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">.yml</span></code> description files tell pkg2appimage where to get the ingredients from, and how to convert them to an AppImage (besides the general steps already included in pkg2appimage). Study some <a class="reference external" href="https://github.com/AppImage/pkg2appimage/tree/master/recipes">examples</a> to see how it works.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>pkg2appimage suffers from a few notable issues:</p>
<blockquote>
<div><ul class="simple">
<li><p>It is likely to add lots of bloat to the final AppImage. As it simply extracts the contents of packages, there is no check whether any of these resources are actually used by the application or not. You are recommended to check final AppImages, and add <code class="docutils literal notranslate"><span class="pre">rm</span></code> commands to your recipes to remove unused data.</p></li>
<li><p>pkg2appimage uses distribution packages downloaded using the package managers, however, the packages are not authenticated, as most security functionality has been deactivated. This is a major security issue. pkg2appimage is therefore recommended for personal use only. Upstream authors should consider <a class="reference internal" href="index.html#ref-from-source"><span class="std std-ref">packaging from source</span></a>.</p></li>
</ul>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See <a class="reference external" href="https://github.com/AppImage/pkg2appimage/issues/197">this GitHub issue</a> for more information on the security issue.</p>
</div>
</div>
</div>
<div class="section" id="yml-files">
<h5><a class="toc-backref" href="#id3"><code class="docutils literal notranslate"><span class="pre">.yml</span></code> files</a><a class="headerlink" href="#yml-files" title="Permalink to this headline">¶</a></h5>
<p>The easiest way to build an AppImage is to write a <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> file. We developed a rather simple format that allows developers to write a <code class="code docutils literal notranslate"><span class="pre">app.yml</span></code> file that describes how to build an AppImage for <code class="code docutils literal notranslate"><span class="pre">app</span></code>, being able to reuse pre-built binaries, e.g. from Debian packages, both to save time for creating and building an AppImage.</p>
<p>This document provides an introduction to the <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> files’ purpose, their structure and a few examples describing how to use all the advanced features.</p>
</div>
<div class="section" id="purpose-of-yml-files">
<h5><a class="toc-backref" href="#id4">Purpose of <code class="docutils literal notranslate"><span class="pre">.yml</span></code> files</a><a class="headerlink" href="#purpose-of-yml-files" title="Permalink to this headline">¶</a></h5>
<p><code class="code docutils literal notranslate"><span class="pre">.yml</span></code> is the file extension commonly used for <em>YAML</em> (<em>Yet Another Markup Language</em>, nowadays also serves as an abbreviation for <em>YAML Ain’t Markup Language</em>).</p>
<p>YAML’s approach to describing data is to combine associative lists (known as <code class="code docutils literal notranslate"><span class="pre">dict</span></code> in Python or <code class="code docutils literal notranslate"><span class="pre">object</span> <span class="pre">literal</span></code> in JavaScript, for example), lists (arrays) and scalar values. This results in an easy to parse and also easy to read format.</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> files are used by <a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/master/pkg2appimage">pkg2appimage</a> which is used in the <em>AppImages</em> project to convert binary <em>ingredients</em> into AppImages for demonstration purposes. Their primary objective is to make it very simple to convert pre-existing binaries into the AppImage format. If you can build your software from source, you may generate AppImages directly as part of your build workflow; in this case you may not need a <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> file (but a Travis CI <code class="code docutils literal notranslate"><span class="pre">.travis.yml</span></code> and/or a <code class="code docutils literal notranslate"><span class="pre">Makefile</span></code>, etc.).</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> file format is not part of the AppImage standard, which just describes the AppImage container format and is agnostic as to how the payload inside an AppImage gets generated. Neither it is part of AppImageKit, because AppImageKit is only concerned with taking a pre-existing <em>AppDir</em> and converting that into an AppImage. Such an AppDir is created from the instructions stored in the <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> files, and converted to an AppImage using <em>AppImageKit</em>.</p>
</div>
<div class="section" id="general-anatomy-of-yml-files">
<h5><a class="toc-backref" href="#id5">General anatomy of <code class="docutils literal notranslate"><span class="pre">.yml</span></code> files</a><a class="headerlink" href="#general-anatomy-of-yml-files" title="Permalink to this headline">¶</a></h5>
<p>The general format of <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> files is as follows:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">(name of the application)</span>
  <span class="l l-Scalar l-Scalar-Plain">(optional flags)</span>

<span class="nt">ingredients</span><span class="p">:</span>
  <span class="l l-Scalar l-Scalar-Plain">(instructions that describe from where to get</span>
  <span class="l l-Scalar l-Scalar-Plain">the binary ingredients used for the AppImage)</span>

<span class="nt">script</span><span class="p">:</span>
  <span class="l l-Scalar l-Scalar-Plain">(instructions on how to convert these ingredients to an AppImage)</span>
</pre></div>
</div>
<p>As you can see, the <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> file consists of three sections:</p>
<ol class="arabic simple">
<li><p>The <strong>overall section</strong> (containing the name of the application and optional flags)</p></li>
<li><p>The <strong>ingredients section</strong> (describing from where to get the binary ingredients used for the AppImage)</p></li>
<li><p>The <strong>script section</strong> (describing how to convert these ingredients to an AppImage)</p></li>
</ol>
<p>Note that the sections may contain sub-sections. For example, the ingredients section can also have a script section containing instructions on how to determine the most recent version of the ingredients and how to download them.</p>
<div class="section" id="overall-section">
<h6>Overall section<a class="headerlink" href="#overall-section" title="Permalink to this headline">¶</a></h6>
<div class="section" id="app-key">
<h7><code class="docutils literal notranslate"><span class="pre">app</span></code> key<a class="headerlink" href="#app-key" title="Permalink to this headline">¶</a></h7>
<p>Mandatory. Contains the name of the application. If the <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> file uses ingredients from packages (e.g., <code class="code docutils literal notranslate"><span class="pre">.deb</span></code>), then the name must match the package name of the main executable.</p>
</div>
<div class="section" id="keys-that-enable-ability-to-relocate">
<h7>Keys that enable ability to relocate<a class="headerlink" href="#keys-that-enable-ability-to-relocate" title="Permalink to this headline">¶</a></h7>
<p>Optional. Either <code class="code docutils literal notranslate"><span class="pre">binpatch:</span> <span class="pre">true</span></code> or <code class="code docutils literal notranslate"><span class="pre">union:</span> <span class="pre">true</span></code>. These keys enable workarounds that make it possible to run applications from different, changing places in the file system (i.e., make them relocateable) that are not made for this. For example, some applications contain hardcoded paths to a compile-time <code class="code docutils literal notranslate"><span class="pre">$PREFIX</span></code> such as <code class="code docutils literal notranslate"><span class="pre">/usr</span></code>. This is generally discouraged, and application authors are asked to use paths relative to the main executable instead. Libraries like <em>binreloc</em> exist to make this easier. Since many applications are not relocateable yet, there are workarounds which can be used by one of these keys:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">binpatch:</span> <span class="pre">true</span></code>  indicates that binaries in the AppImage should be patched to replace the string <code class="code docutils literal notranslate"><span class="pre">/usr</span></code> by the string <code class="code docutils literal notranslate"><span class="pre">././</span></code>,  an <code class="code docutils literal notranslate"><span class="pre">AppRun</span></code> file should be put inside the AppImage that does a <code class="code docutils literal notranslate"><span class="pre">chdir()</span></code> to the <code class="code docutils literal notranslate"><span class="pre">usr/</span></code> directory of inside AppDir before executing the payload application. The net effect is this that applications can find their resources in the  <code class="code docutils literal notranslate"><span class="pre">usr/</span></code> directory inside the AppImage as long as they do not internally use <code class="code docutils literal notranslate"><span class="pre">chdir()</span></code> operations themselves.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">union:</span> <span class="pre">true</span></code> indicates that an <code class="code docutils literal notranslate"><span class="pre">AppRun</span></code> file should be put inside the AppImage that tries to create the impression of a union file system, effectively creating the impression to the payload application that the contents of the AppImage are overlayed over <code class="code docutils literal notranslate"><span class="pre">/</span></code>. This can be achieved, e.g., using <code class="code docutils literal notranslate"><span class="pre">LD_PRELOAD</span></code> and a library that redirects file system calls. This works as long as the payload application is a dynamically linked binary.</p></li>
</ul>
</div>
</div>
<div class="section" id="ingredients-section">
<h6>Ingredients section<a class="headerlink" href="#ingredients-section" title="Permalink to this headline">¶</a></h6>
<p>Describes how to acquire the binary ingredients that go into the AppImage. Binary ingredients can be archives like <code class="code docutils literal notranslate"><span class="pre">.zip</span></code> files, packages like <code class="code docutils literal notranslate"><span class="pre">.deb</span></code> files or APT repositories like Debian package archives or PPAs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the future, source ingredients could also be included in the <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> file definition. Source ingredients could include tarballs and Git repositories. It would probably be advantageous if we could share the definition with other formats like snapcraft’s <code class="code docutils literal notranslate"><span class="pre">.yaml</span></code> files. Proposals for this are welcome.</p>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">.yml</span></code> files are supposed not to hardcode version numbers, but determine the latest version at runtime. If the  <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> files describes the released version, it should determine the latest released version at runtime. If the  <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> files describes the development version, it might reference the latest nightly or continuous build instead.</p>
<div class="section" id="using-ingredients-from-a-binary-archive">
<h7>Using ingredients from a binary archive<a class="headerlink" href="#using-ingredients-from-a-binary-archive" title="Permalink to this headline">¶</a></h7>
<p>The following example ingredients section describes how to get the latest version of a binary archive:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">script</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">DLD=$(wget -q &quot;https://api.github.com/repos/atom/atom/releases/latest&quot; -O - | grep -E &quot;https.*atom-amd64.tar.gz&quot; | cut -d&#39;&quot;&#39; -f4)</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">wget -c $DLD</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">tar zxvf atom*tar.gz</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">script</span></code> section inside the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section determines its URL, downloads and extracts the binary archive.</p>
</div>
<div class="section" id="using-ingredients-from-a-debian-repository">
<h7>Using ingredients from a debian repository<a class="headerlink" href="#using-ingredients-from-a-debian-repository" title="Permalink to this headline">¶</a></h7>
<p>The following example ingredients section describes how to get the latest version of a package from a Debian archive:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">dist</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">xenial</span>
  <span class="nt">sources</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://archive.ubuntu.com/ubuntu/ xenial main universe</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://download.opensuse.org/repositories/isv:/KDAB/xUbuntu_16.04/ /</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">dist</span></code> section inside the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section defines which Debian distribution should be used as a base. The <code class="code docutils literal notranslate"><span class="pre">sources</span></code> section inside the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section describes the repositories from which the package should be pulled. The entries are in the same format as lines in a debian <code class="code docutils literal notranslate"><span class="pre">sources.list</span></code> file. Note that the <code class="code docutils literal notranslate"><span class="pre">http://download.opensuse.org/repositories/isv:/KDAB/xUbuntu_16.04</span></code> repository needs the <code class="code docutils literal notranslate"><span class="pre">http://archive.ubuntu.com/ubuntu/</span></code> repository so that the dependencies can be resolved.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the future, other types of packages like <code class="code docutils literal notranslate"><span class="pre">.rpm</span></code> could also be included in the <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> file definition. Proposals for this are welcome if the proposer also implements support for this in the <a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/master/pkg2appimage">pkg2appimage</a> script.</p>
</div>
</div>
<div class="section" id="using-ingredients-from-an-ubuntu-ppa">
<h7>Using ingredients from an Ubuntu PPA<a class="headerlink" href="#using-ingredients-from-an-ubuntu-ppa" title="Permalink to this headline">¶</a></h7>
<p>This is a special case of a Debian repository. PPAs can be uniquely identified with the pattern <code class="code docutils literal notranslate"><span class="pre">owner/name</span></code> and can, for brevity, be specified like this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">dist</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">xenial</span>
  <span class="nt">sources</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://us.archive.ubuntu.com/ubuntu/ xenial main universe</span>
  <span class="nt">ppas</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">geany-dev/ppa</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">ppas</span></code> section inside the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section lets you specify one or more Ubuntu PPAs. This is equivalent to, but more elegant than, adding the corresponding <code class="code docutils literal notranslate"><span class="pre">sources.list</span></code> entries to the <code class="code docutils literal notranslate"><span class="pre">sources</span></code> section inside the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the future, similar shortcuts for other types of personal repositories, such as projects on openSUSE build service, could also be included in the <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> file definition. Proposals for this are welcome if the proposer also implements support for this in the <a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/master/pkg2appimage">pkg2appimage</a> script.</p>
</div>
</div>
<div class="section" id="using-local-deb-files">
<h7>Using local deb files<a class="headerlink" href="#using-local-deb-files" title="Permalink to this headline">¶</a></h7>
<p>This allows the use of local deb files (rather than downloading the deb ingredients)</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">dist</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">xenial</span>
  <span class="nt">sources</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://us.archive.ubuntu.com/ubuntu/ xenial main universe</span>
  <span class="nt">debs</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">/home/area42/kdenlive.deb</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">/home/area42/kdenlive/*</span>
</pre></div>
</div>
<p>As you can see, for a single file, just use</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">/path/to/file.deb</span>
</pre></div>
</div>
<p>And for all files in a directory (like local repository). Note that the end of the path ends with <code class="code docutils literal notranslate"><span class="pre">/*</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">/path/to/local/repo/*</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this is for personal use, if you use your recipe it will NOT work on another computer if the debs files are not in the specified directory</p>
</div>
</div>
<div class="section" id="excluding-certain-packages">
<h7>Excluding certain packages<a class="headerlink" href="#excluding-certain-packages" title="Permalink to this headline">¶</a></h7>
<p>Some packages declare dependencies that are not necessarily required to run the software. The <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> format allow overriding these by pretending that the packages are installed already. To exclude these dependencies (and any dependencies they would otherwise pull in), the packages have to be added to the <code class="code docutils literal notranslate"><span class="pre">exclude</span></code> key in the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">dist</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">xenial</span>
  <span class="nt">packages</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">multisystem</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">gksu</span>
  <span class="nt">sources</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://us.archive.ubuntu.com/ubuntu/ xenial main universe</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://liveusb.info/multisystem/depot all main</span>
  <span class="nt">exclude</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">qemu</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">qemu-kvm</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cryptsetup</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">libwebkitgtk-3.0-0</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">dmsetup</span>
</pre></div>
</div>
<p>In this example, excluding <code class="code docutils literal notranslate"><span class="pre">qemu</span></code> means that the qemu package and all of its dependencies that it would normally pull into the AppImage will be excluded from the AppImage (unless something else in the AppImage pulls in some of those depdencies already).</p>
</div>
<div class="section" id="pretending-certain-versions-of-dependencies-being-installed">
<h7>Pretending certain versions of dependencies being installed<a class="headerlink" href="#pretending-certain-versions-of-dependencies-being-installed" title="Permalink to this headline">¶</a></h7>
<p>The dependency information in some packages may result in the package manager to refuse the application to be installed if some <strong>exact</strong> versions of dependencies are not present in the system. In this case, it may be necessary pretend the <strong>exact</strong> version of a dependency to be installed on the target system by using the <code class="code docutils literal notranslate"><span class="pre">pretend</span></code> key in the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">dist</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">xenial</span>
  <span class="nt">sources</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://archive.ubuntu.com/ubuntu/ xenial main universe</span>
  <span class="nt">ppas</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">otto-kesselgulasch/gimp-edge</span>
  <span class="nt">pretend</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">libcups2 1.7.2-0ubuntu1</span>
</pre></div>
</div>
<p>The assumption here is that every target system has at least the pretended version available, and that newer versions of the pretended package are able to run the application just as well as the pretended version itself <em>(if this is not the case, then the pretended package has broken downward compatibility and should be fixed)</em>.</p>
</div>
<div class="section" id="arbitrary-scripts-in-the-ingredients-section">
<h7>Arbitrary scripts in the ingredients section<a class="headerlink" href="#arbitrary-scripts-in-the-ingredients-section" title="Permalink to this headline">¶</a></h7>
<p>You may add arbitrary shell commands to the <code class="code docutils literal notranslate"><span class="pre">script</span></code> section inside the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section in order to facilitate the retrieval of the binary ingredients. This allows building AppImages for complex situations as illustrated in the following example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">script</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">URL=$(wget -q https://www.fosshub.com/JabRef.html -O - | grep jar | cut -d &#39;&quot;&#39; -f 10)</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">wget -c &quot;$URL&quot;</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">wget -c --no-check-certificate --no-cookies --header &quot;Cookie</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u66-b17/jre-8u66-linux-x64.tar.gz</span>
</pre></div>
</div>
<p>This downloads the payload application, JabRef, and the required JRE which requires to set a special cookie header.</p>
<p>The script could also be used to fetch pre-built Debian packages from a GitHub release page, or to override the version of a package.</p>
<p>Use <code class="code docutils literal notranslate"><span class="pre">post_script</span></code> instead of <code class="code docutils literal notranslate"><span class="pre">script</span></code> if you need this to run <em>after</em> the other ingredient processing has taken place.</p>
</div>
</div>
<div class="section" id="script-section">
<h6>Script section<a class="headerlink" href="#script-section" title="Permalink to this headline">¶</a></h6>
<p>The <code class="code docutils literal notranslate"><span class="pre">script</span></code> section may contain arbitrary shell commands that are required to translate the binary ingredients to an <code class="code docutils literal notranslate"><span class="pre">AppDir</span></code> suitable for generating an AppImage.</p>
<div class="section" id="the-script-section-needs-to-copy-ingredients-into-place">
<h7>The script section needs to copy ingredients into place<a class="headerlink" href="#the-script-section-needs-to-copy-ingredients-into-place" title="Permalink to this headline">¶</a></h7>
<p>If <code class="code docutils literal notranslate"><span class="pre">.deb</span></code> packages, Debian repositories or PPAs have been specified in the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section, then their dependencies are resolved automatically (taking a blacklist of packages that are assumed to be present on all target systems in a recent enough version into account, such as glibc) and the packages are extracted into an AppDir. The shell commands contained in the <code class="code docutils literal notranslate"><span class="pre">script</span></code> section are executed inside the root directory of this AppDir. However, some packages place things in non-standard locations, i.e. the main executable is outside of <code class="code docutils literal notranslate"><span class="pre">usr/bin</span></code>. In these cases, the commands contained in the <code class="code docutils literal notranslate"><span class="pre">script</span></code> section should normalize the file system structure. Sometimes it is also necessary to edit further files to reflect the changed file location. The following example illustrates this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">dist</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">xenial</span>
  <span class="nt">sources</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://archive.ubuntu.com/ubuntu/ xenial main universe</span>

  <span class="nt">script</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">DLD=$(wget -q &quot;https://github.com/feross/webtorrent-desktop/releases/&quot; -O - | grep _amd64.deb | head -n 1 | cut -d &#39;&quot;&#39; -f 2)</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">wget -c &quot;https://github.com/$DLD&quot;</span>

<span class="nt">script</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">mv opt/webtorrent-desktop/* usr/bin/</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">sed -i -e &#39;s|/opt/webtorrent-desktop/||g&#39; webtorrent-desktop.desktop</span>
</pre></div>
</div>
<p>In the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section, a <code class="code docutils literal notranslate"><span class="pre">.deb</span></code> package is downloaded. Then, in the <code class="code docutils literal notranslate"><span class="pre">script</span></code> section, the main executable is moved to its standard location in the AppDir. Finally, the <code class="code docutils literal notranslate"><span class="pre">.desktop</span></code> file is updated to reflect this.</p>
<p>If other types of binary ingredients have been specified, then the shell commands contained in the <code class="code docutils literal notranslate"><span class="pre">script</span></code> section need to retrieve these by copying them into place. Note that since the commands contained in the <code class="code docutils literal notranslate"><span class="pre">script</span></code> section are executed inside the root directory of the AppDir, the ingredients downloaded in the <cite>ingredients</cite> sections are one directory level above, i.e., in <code class="code docutils literal notranslate"><span class="pre">../</span></code>. The following example illustrates this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">script</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">wget -c &quot;https://telegram.org/dl/desktop/linux&quot; --trust-server-names</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">tar xf tsetup.*.tar.xz</span>

<span class="nt">script</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cp ../Telegram/Telegram ./usr/bin/telegram-desktop</span>
</pre></div>
</div>
<p>In the <code class="code docutils literal notranslate"><span class="pre">ingredients</span></code> section, an archive is downloaded and unpacked. Then, in the <code class="code docutils literal notranslate"><span class="pre">script</span></code> section, the main executable is copied into place inside the AppDir.</p>
</div>
<div class="section" id="the-script-section-needs-to-copy-icon-and-desktop-file-in-place">
<h7>The script section needs to copy icon and <cite>.desktop</cite> file in place<a class="headerlink" href="#the-script-section-needs-to-copy-icon-and-desktop-file-in-place" title="Permalink to this headline">¶</a></h7>
<p>Since an AppImage may contain more than one executable binary (e.g. helper binaries launched by the main executable) and also may contain multiple <code class="code docutils literal notranslate"><span class="pre">.desktop</span></code> files, a clear entry point into the AppImage is required. For this reason, there is the convention that there should be exactly one <code class="code docutils literal notranslate"><span class="pre">$ID.desktop</span></code> file and corresponding icon file in the top-level directory of the AppDir.</p>
<p>The script running the <code class="code docutils literal notranslate"><span class="pre">.yml</span></code> file tries to do this automatically, which works if the name of the application specified in the <code class="code docutils literal notranslate"><span class="pre">app:</span></code> key matches the name of the <code class="code docutils literal notranslate"><span class="pre">$ID.desktop</span></code> file and the corresponding icon file. For example, if <code class="code docutils literal notranslate"><span class="pre">app:</span> <span class="pre">myapp</span></code> is set, and there is <code class="code docutils literal notranslate"><span class="pre">usr/bin/myapp</span></code>, <code class="code docutils literal notranslate"><span class="pre">usr/share/applications/myapp.desktop</span></code>, and <code class="code docutils literal notranslate"><span class="pre">usr/share/icons/*/myapp.png</span></code>, then the <code class="code docutils literal notranslate"><span class="pre">myapp.desktop</span></code> and <code class="code docutils literal notranslate"><span class="pre">myapp.png</span></code> files are automatically copied into the top-level directory of the AppDir. Unfortunately, many packages are  in their naming. In that case, the shell commands contained in the <code class="code docutils literal notranslate"><span class="pre">script</span></code> section must copy exactly one <code class="code docutils literal notranslate"><span class="pre">$ID.desktop</span></code> file and the corresponding icon file into the top-level directory of the AppDir. The following example illustrates this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">script</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">tar xf ../fritzing* -C usr/bin/ --strip 1</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">mv usr/bin/fritzing.desktop .</span>
</pre></div>
</div>
<p>Unfortunately, many applications don’t include a <code class="code docutils literal notranslate"><span class="pre">$ID.desktop</span></code> file. If it is missing, the shell commands contained in the <code class="code docutils literal notranslate"><span class="pre">script</span></code> section need to create it. The following (simplified) example illustrates this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">script</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="c1"># Workaround for:</span>
  <span class="p p-Indicator">-</span> <span class="c1"># https://bugzilla.mozilla.org/show_bug.cgi?id=296568</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cat &gt; firefox.desktop &lt;&lt;EOF</span>
  <span class="p p-Indicator">-</span> <span class="p p-Indicator">[</span><span class="nv">Desktop Entry</span><span class="p p-Indicator">]</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Type=Application</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Name=Firefox</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Icon=firefox</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Exec=firefox %u</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Categories=GNOME;GTK;Network;WebBrowser;</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">MimeType=text/html;text/xml;application/xhtml+xml;</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">StartupNotify=true</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">EOF</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The optional <code class="code docutils literal notranslate"><span class="pre">desktopintegration</span></code> script assumes that the name of the application specified in the <code class="code docutils literal notranslate"><span class="pre">app:</span></code> key matches the name of the <code class="code docutils literal notranslate"><span class="pre">$ID.desktop</span></code> file and the corresponding main executable (case-sensitive). For example, if <code class="code docutils literal notranslate"><span class="pre">app:</span> <span class="pre">myapp</span></code> is set, it expects <code class="code docutils literal notranslate"><span class="pre">usr/bin/myapp`and</span> <span class="pre">:code:`usr/share/applications/myapp.desktop</span></code>. For this reason, if you want to use the optional <code class="code docutils literal notranslate"><span class="pre">desktopintegration</span></code> script, you may rearrange the AppDir. The following example illustrates this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">script</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cp ./usr/share/applications/FBReader.desktop fbreader.desktop</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">sed -i -e &#39;s|Exec=FBReader|Exec=fbreader|g&#39; fbreader.desktop</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">sed -i -e &#39;s|Name=.*|Name=FBReader|g&#39; fbreader.desktop</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">sed -i -e &#39;s|Icon=.*|Icon=fbreader|g&#39; fbreader.desktop</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">mv usr/bin/FBReader usr/bin/fbreader</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cp usr/share/pixmaps/FBReader.png fbreader.png</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="converting-python-applications-packaged-with-pip">
<h5><a class="toc-backref" href="#id6">Converting Python applications packaged with pip</a><a class="headerlink" href="#converting-python-applications-packaged-with-pip" title="Permalink to this headline">¶</a></h5>
<p>Let’s say you have already packaged your Python application using <code class="code docutils literal notranslate"><span class="pre">pip</span></code>. in this case, you can use the <code class="code docutils literal notranslate"><span class="pre">pkg2appimage</span></code> tool to generate an AppImage. In the following example, we will convert a Python 3 application using <code class="code docutils literal notranslate"><span class="pre">pip3</span></code>.</p>
<p>The following recipe will convert a Python 3 PyQt application using <code class="code docutils literal notranslate"><span class="pre">virtualenv</span></code> and <code class="code docutils literal notranslate"><span class="pre">pip3</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">mu.codewith.editor</span>
<span class="nt">ingredients</span><span class="p">:</span>
  <span class="nt">dist</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">xenial</span>
  <span class="nt">sources</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://us.archive.ubuntu.com/ubuntu/ xenial xenial-updates xenial-security main universe</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://us.archive.ubuntu.com/ubuntu/ xenial-updates main universe</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">deb http://us.archive.ubuntu.com/ubuntu/ xenial-security main universe</span>
  <span class="nt">packages</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python3.4-venv</span>
  <span class="nt">script</span><span class="p">:</span>
    <span class="p p-Indicator">-</span>  <span class="l l-Scalar l-Scalar-Plain">wget -c https://raw.githubusercontent.com/mu-editor/mu/master/conf/mu.codewith.editor.png</span>
    <span class="p p-Indicator">-</span>  <span class="l l-Scalar l-Scalar-Plain">wget -c https://raw.githubusercontent.com/mu-editor/mu/master/conf/mu.appdata.xml</span>
<span class="nt">script</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cp ../mu.codewith.editor.png ./usr/share/icons/hicolor/256x256/</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cp ../mu.codewith.editor.png .</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">mkdir -p usr/share/metainfo/ ; cp ../mu.appdata.xml usr/share/metainfo/</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">virtualenv --python=python3 usr</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">./usr/bin/pip3 install mu-editor</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cat &gt; usr/share/applications/mu.codewith.editor.desktop &lt;&lt;\EOF</span>
  <span class="p p-Indicator">-</span> <span class="p p-Indicator">[</span><span class="nv">Desktop Entry</span><span class="p p-Indicator">]</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Type=Application</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Name=Mu</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Comment=A Python editor for beginner programmers</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Icon=mu.codewith.editor</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Exec=python3 bin/mu-editor %F</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Terminal=false</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Categories=Application;Development;</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">Keywords=Python;Editor;microbit;micro:bit;</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">StartupWMClass=mu</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">MimeType=text/x-python3;text/x-python3;</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">EOF</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cp usr/share/applications/mu.codewith.editor.desktop .</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">usr/bin/pip3 freeze | grep &quot;mu-editor&quot; | cut -d &quot;=&quot; -f 3 &gt;&gt; ../VERSION</span>
</pre></div>
</div>
<dl class="simple">
<dt>Source:</dt><dd><p><a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/9249a99e653272416c8ee8f42cecdde12573ba3e/recipes/Mu.yml">https://github.com/AppImage/pkg2appimage/blob/9249a99e653272416c8ee8f42cecdde12573ba3e/recipes/Mu.yml</a></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<span id="document-packaging-guide/optional/index"></span><div class="section" id="optional-resources-and-features">
<h3>Optional Resources and Features<a class="headerlink" href="#optional-resources-and-features" title="Permalink to this headline">¶</a></h3>
<p>If you have followed our packaging guide to this point: congratulations! You should have a working AppImage by now.</p>
<p>However, the produced AppImage can be improved further. We provide some additional features such as <a class="reference internal" href="index.html#ref-updates"><span class="std std-ref">binary delta updating</span></a> and a standardized and verifiable <span class="xref std std-ref">signature mechanism</span>.</p>
<p>Also, you can add optional resources such as <a class="reference internal" href="index.html#ref-appstream"><span class="std std-ref">AppStream metadata</span></a> to allow tools which work with AppImages such as <a class="reference internal" href="index.html#ref-appimagehub"><span class="std std-ref">AppImageHub</span></a> to display additional information about your AppImage.</p>
<p>The following section explains these optional features and resources, and shows how these can be enabled resp. added.</p>
<div class="toctree-wrapper compound">
<span id="document-packaging-guide/optional/updates"></span><div class="section" id="making-appimages-updateable">
<span id="ref-updates"></span><h4>Making AppImages updateable<a class="headerlink" href="#making-appimages-updateable" title="Permalink to this headline">¶</a></h4>
<p>AppImages can be updated:</p>
<blockquote>
<div><ul class="simple">
<li><p>Via external tools (e.g., <code class="code docutils literal notranslate"><span class="pre">AppImageUpdate</span></code> or the <code class="code docutils literal notranslate"><span class="pre">appimageupdatetool</span></code> command line tool)</p></li>
<li><p>Via an updater tool built into the AppImage itself</p></li>
<li><p>By consuming <code class="code docutils literal notranslate"><span class="pre">libappimageupdate</span></code> functionality inside the payload application</p></li>
</ul>
</div></blockquote>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#making-appimages-updateable-via-external-tools" id="id1">Making AppImages updateable via external tools</a></p>
<ul>
<li><p><a class="reference internal" href="#using-appimagetool" id="id2">Using appimagetool</a></p></li>
<li><p><a class="reference internal" href="#using-linuxdeploy" id="id3">Using linuxdeploy</a></p></li>
<li><p><a class="reference internal" href="#using-linuxdeployqt" id="id4">Using linuxdeployqt</a></p></li>
<li><p><a class="reference internal" href="#using-electron-builder" id="id5">Using electron-builder</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#making-appimages-self-updateable" id="id6">Making AppImages self-updateable</a></p>
<ul>
<li><p><a class="reference internal" href="#via-appimageupdate-built-into-the-appimage" id="id7">Via AppImageUpdate built into the AppImage</a></p></li>
<li><p><a class="reference internal" href="#by-using-libappimageupdate" id="id8">By using <cite>libappimageupdate</cite></a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="making-appimages-updateable-via-external-tools">
<h5><a class="toc-backref" href="#id1">Making AppImages updateable via external tools</a><a class="headerlink" href="#making-appimages-updateable-via-external-tools" title="Permalink to this headline">¶</a></h5>
<p>To make an AppImage updateable, you need to embed information that describes where to check for updates and how into the AppImage. Unlike other Linux distribution methods, the information where to look for updates is not contained in separate repository description files such as <code class="code docutils literal notranslate"><span class="pre">sources.list</span></code> that need to be managed by the user, but is directly embedded inside the AppImage by the author of the respective AppImage. This has the advantage that the update information always travels alongside the application, so that the end user does not have to do anything special in order to be able to check for updates.</p>
<div class="section" id="using-appimagetool">
<h6><a class="toc-backref" href="#id2">Using appimagetool</a><a class="headerlink" href="#using-appimagetool" title="Permalink to this headline">¶</a></h6>
<p>Use <code class="code docutils literal notranslate"><span class="pre">appimagetool</span> <span class="pre">-u</span></code> to embed update information (as specified in the AppImageSpec) and generate the corresponding <code class="code docutils literal notranslate"><span class="pre">.zsync</span></code> file you can upload to the place mentioned in the update information.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>appimagetool videocapture.AppDir/usr/share/applications/*.desktop -u <span class="s2">&quot;zsync|https://lyrion.ch/opensource/repositories/videocapture/uv/videocapture.AppImage.zsync&quot;</span>
</pre></div>
</div>
<p>The string</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>zsync|https://lyrion.ch/opensource/repositories/videocapture/uv/videocapture.AppImage.zsync
</pre></div>
</div>
<p>is called the <em>update information</em>.</p>
<p>Please see <a class="reference external" href="https://github.com/AppImage/AppImageSpec/blob/master/draft.md#update-information">https://github.com/AppImage/AppImageSpec/blob/master/draft.md#update-information</a> for a description of allowable types of update information.</p>
</div>
<div class="section" id="using-linuxdeploy">
<h6><a class="toc-backref" href="#id3">Using linuxdeploy</a><a class="headerlink" href="#using-linuxdeploy" title="Permalink to this headline">¶</a></h6>
<p><a class="reference internal" href="index.html#ref-linuxdeploy"><span class="std std-ref">linuxdeploy’s</span></a> <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy-plugin-appimage">AppImage plugin</a> supports an environment variable <code class="docutils literal notranslate"><span class="pre">$UPDATE_INFORMATION</span></code> (or short <code class="docutils literal notranslate"><span class="pre">$UPD_INFO</span></code>) that can be used to set the update information manually.</p>
<p>Please see <a class="reference external" href="https://github.com/linuxdeploy/linuxdeploy-plugin-appimage#optional-variables">the README</a> for details.</p>
</div>
<div class="section" id="using-linuxdeployqt">
<h6><a class="toc-backref" href="#id4">Using linuxdeployqt</a><a class="headerlink" href="#using-linuxdeployqt" title="Permalink to this headline">¶</a></h6>
<p><code class="code docutils literal notranslate"><span class="pre">linuxdeployqt</span></code> uses <code class="code docutils literal notranslate"><span class="pre">appimagetool</span></code> internally. If it recognizes that it is running on Travis CI, then it automatically generates the matching update information.</p>
</div>
<div class="section" id="using-electron-builder">
<h6><a class="toc-backref" href="#id5">Using electron-builder</a><a class="headerlink" href="#using-electron-builder" title="Permalink to this headline">¶</a></h6>
<p><code class="code docutils literal notranslate"><span class="pre">electron-builder</span></code> promotes its own updater scheme rather than the update information described in this documentation, in order to have the same mechanism on Linux as is used on Windows. Unfortunately this means that AppImages generated by <code class="code docutils literal notranslate"><span class="pre">electron-builder</span></code> cannot be updated using the usual tools.</p>
<p>One way to inject the update information into the AppImage created with <code class="code docutils literal notranslate"><span class="pre">electron-builder</span></code> nevertheless is to extract the AppImage generated with <code class="code docutils literal notranslate"><span class="pre">electron-builder</span></code> to an AppDir using the –appimage-extract command line option of the AppImage, and then re-packing it as an AppImage by using <code class="code docutils literal notranslate"><span class="pre">appimagetool</span> <span class="pre">-u</span></code>.</p>
</div>
</div>
<div class="section" id="making-appimages-self-updateable">
<h5><a class="toc-backref" href="#id6">Making AppImages self-updateable</a><a class="headerlink" href="#making-appimages-self-updateable" title="Permalink to this headline">¶</a></h5>
<p>Once you have made your AppImage updateable via external tools as described above, you may optionally go one step further and bundle everything that is required to update an AppImage inside the AppImage itself, so that the user can get updates without needing anything besides the AppImage itself. This is conceptually similar to how the <a class="reference external" href="https://sparkle-project.org/">Sparkle Framework</a> works on macOS.</p>
<div class="section" id="via-appimageupdate-built-into-the-appimage">
<h6><a class="toc-backref" href="#id7">Via AppImageUpdate built into the AppImage</a><a class="headerlink" href="#via-appimageupdate-built-into-the-appimage" title="Permalink to this headline">¶</a></h6>
<p>You can bundle <code class="code docutils literal notranslate"><span class="pre">AppImageUpdate</span></code> itself inside the AppImage of your application. In order to have the bundled AppImageUpdate update your running AppImage when the user invokes some command in your application (e.g., an “Update…” menu) in your GUI, simply have your application invoke <code class="code docutils literal notranslate"><span class="pre">AppImageUpdate</span> <span class="pre">$APPIMAGE</span></code>. If <code class="code docutils literal notranslate"><span class="pre">AppImageUpdate</span></code> is bundled inside the AppImage and is on the <code class="code docutils literal notranslate"><span class="pre">$PATH</span></code>, this will work.</p>
</div>
<div class="section" id="by-using-libappimageupdate">
<h6><a class="toc-backref" href="#id8">By using <cite>libappimageupdate</cite></a><a class="headerlink" href="#by-using-libappimageupdate" title="Permalink to this headline">¶</a></h6>
<div class="section" id="recommended-user-experience">
<h7>Recommended user experience<a class="headerlink" href="#recommended-user-experience" title="Permalink to this headline">¶</a></h7>
<p>One advantage of the AppImage format is that it gives full control to application authors over the end user experience. Hence, using AppImage and AppImageUpdate, application authors can implement almost any of the schemes outlined above. In order to maintain a consistent and positive user experience with AppImages and AppImageUpdate, we recommend application authors to follow the following <strong>Golden Rules</strong>:</p>
<ul class="simple">
<li><p>Never download updates without the user’s explicit consent, be it in the form of per-update consent, or, optionally, opt-in consent for automatic updates. Thanks for not killing users’ mobile data plans by downloading stuff without asking</p></li>
<li><p>Respect global flags for <strong>“do not check for new versions”</strong> and <strong>“do not attempt to update”</strong>. The user may be running a central updating daemon that manages updates for the whole system, in which case any and all attempts to update the application from within itself should be skipped. <strong>We need to define those flags for 1) per-system and 2) per-user configuration and 3) ENV</strong> (similar to how the old <code class="code docutils literal notranslate"><span class="pre">desktopintegration</span></code> script was set up not to interfere with <code class="code docutils literal notranslate"><span class="pre">appimaged</span></code>)</p></li>
<li><p>Do not bother the user with updates directly as the first thing when the application is launched. When opening an application for the first time, users should see something meaningful to give a positive impression and show immediately what the application is all about (after all, we are automatically taking a screenshot of what your application shows directly after it has been launched for AppImageHub)</p></li>
<li><p>Ask the user for permission before doing version checks. Many open source users value privacy highly and don’t appreciate the “phone home” aspect of forced version checks, which effectively are a form of tracking</p></li>
</ul>
<a class="reference internal image-reference" href="_images/updates-realworld-example.png"><img alt="SonicVisualiser GUI asking for network access permission" src="_images/updates-realworld-example.png" style="width: 80%;" /></a>
<ul class="simple">
<li><p>The update should ideally be nicely integrated into the GUI of your application, using whatever GUI toolkit you are using. We are interested in getting libraries for popular GUI toolkits like Qt, Gkt+ 2 and 3, WxWidgets, etc. - so if you implement this, please share with the world</p></li>
<li><p>During the update process, your application should remain fully usable (this works because the original file is not changed by the update process; instead a new file with the new version is placed next to the original one)</p></li>
<li><p>Releases should always update to releases, nightlies always to nightlies, etc. (“channels”)</p></li>
<li><p>Whenever the application encounters issues (e.g., a crash reporter comes up) it could ask the user to check for updates, and accept bug reports only if no newer version is available in the channel</p></li>
</ul>
</div>
<div class="section" id="building-and-linking-libappimageupdate">
<h7>Building and linking libappimageupdate<a class="headerlink" href="#building-and-linking-libappimageupdate" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This guide assumes you are using Git and CMake to build your project.</p>
</div>
<p>There’s two options how to add libappimageupdate to your project: Either you use a Git submodule (the preferred way), or you use CMake’s <code class="code docutils literal notranslate"><span class="pre">ExternalProject</span></code>. The latter is a more complex issue and has some implications, therefore this guide focuses on the former option.</p>
<p>The guide assumes the following directory layout:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span>                       <span class="c1"># repository root</span>
    <span class="n">lib</span><span class="o">/</span>                <span class="c1"># external libraries</span>
        <span class="o">...</span>             <span class="c1"># other libraries that might be used</span>
        <span class="n">CMakeLists</span><span class="o">.</span><span class="n">txt</span>  <span class="c1"># manages the dependencies for CMake</span>
    <span class="n">src</span><span class="o">/</span>                <span class="c1"># source files</span>
        <span class="n">CMakeLists</span><span class="o">.</span><span class="n">txt</span>  <span class="c1"># defines the binaries to build</span>
        <span class="n">main</span><span class="o">.</span><span class="n">cpp</span>        <span class="c1"># main application</span>
    <span class="n">CMakeLists</span><span class="o">.</span><span class="n">txt</span>      <span class="c1"># top level CMake configuration</span>
</pre></div>
</div>
<p>First of all, add the AppImageUpdate repository as a submodule.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ git submodule add https://github.com/AppImage/AppImageUpdate lib/AppImageUpdate
</pre></div>
</div>
<p>You will have to initialize your submodule. AppImageUpdate pulls in some dependencies as well. Therefore, anyone using your repository will have to run the following command after cloning (unless they called <code class="code docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span> <span class="pre">--recursive</span></code>):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ git submodule update --init --recursive
</pre></div>
</div>
<p>Please refer to the <a class="reference external" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">Git book</a> for more information about submodules and how they work, how to update them etc.</p>
<p>Next, instruct CMake that you want to use the library. Add <code class="code docutils literal notranslate"><span class="pre">add_subdirectory(AppImageUpdate)</span></code> to <code class="code docutils literal notranslate"><span class="pre">lib/CMakeLists.txt</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You need to call <code class="code docutils literal notranslate"><span class="pre">add_subdirectory(lib)</span></code> within the top-level <code class="code docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> near the top before defining executables etc. to make this work. Furthermore, somewhere below, CMakeLists.txt needs to include the <code class="code docutils literal notranslate"><span class="pre">src</span></code> directory. Like with the <code class="code docutils literal notranslate"><span class="pre">lib</span></code> directory, there should be a <code class="code docutils literal notranslate"><span class="pre">add_subdirectory(src)</span></code> call.</p>
</div>
<p>Now instruct CMake to link your libraries and/or executables to libappimageupdate. AppImageUpdate’s CMake build infrastructure defines a target <code class="code docutils literal notranslate"><span class="pre">libappimageupdate</span></code>.</p>
<p>Open <code class="code docutils literal notranslate"><span class="pre">src/CMakeLists.txt</span></code>, find your <code class="code docutils literal notranslate"><span class="pre">add_library/add_executable</span></code> call, and add the following snippet below:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">mytarget</span> <span class="s">PRIVATE</span> <span class="s">libappimageupdate</span><span class="p">)</span>
</pre></div>
</div>
<p>Now everything should be up and running! Congratulations!</p>
</div>
<div class="section" id="using-libappimageupdate-within-app-store-like-applications">
<h7>Using libappimageupdate within app store like applications<a class="headerlink" href="#using-libappimageupdate-within-app-store-like-applications" title="Permalink to this headline">¶</a></h7>
<p>Consider the following scenario:</p>
<p>You have an app store app managing AppImages. As you know, AppImages don’t require an installation. The only thing you have to do is download them and make them executable, and your users can run them. To remove them from the system, all that has to be done is removing a single file from the file system.</p>
<p>So far, so good. But what about updates? Ideally, the upstream projects are actively developed, and publish releases regularly. However, with technologies like Electron becoming more and more popular, AppImage file sizes of several 10s of MiB are pretty common. Games even have a few 100 MiB, bundling all the data.</p>
<p>To mitigate those problems, AppImageUpdate provides an efficient solution to these problems. It compares the local AppImage with the remote, up to date file, uses all usable data from the existing file, and downloads the remaining data only. This does not only save a lot of bandwidth, but also speeds up the update processes.</p>
<p>libappimageupdate provides a class called <code class="code docutils literal notranslate"><span class="pre">appimage::update::Updater</span></code> capable of updating a single AppImage. It contains features like an update check, running updates in a separate thread, a status message system, progress indicator support and a lot more.</p>
<p>Basic usage:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">appimage</span><span class="o">::</span><span class="n">update</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">Updater</span> <span class="nf">updater</span><span class="p">(</span><span class="s">&quot;test.AppImage&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, you can use the <code class="code docutils literal notranslate"><span class="pre">updater</span></code> object to perform operations. The API is built on the principle of <em>pervasive error handling</em>, i.e., all operations that might fail in any way provide error handling. In libappimageupdate, this is implemented by making such methods become boolean, and accept a reference to the result type which is set in case of success. The method returns either <code class="code docutils literal notranslate"><span class="pre">true</span></code>, which means the operation succeeded, or <code class="code docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<p>See this easy example for an update check:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// check for update</span>
<span class="kt">bool</span> <span class="n">updateAvailable</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">updater</span><span class="p">.</span><span class="n">checkForChanges</span><span class="p">(</span><span class="n">updateAvailable</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// return error state</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">updateAvailable</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// perform update ...</span>
</pre></div>
</div>
<p>This is faster and less verbose than an exception based workflow, however, you can’t see what caused the update check to fail.</p>
<p>This can be found out using the built in status message system. Every <code class="code docutils literal notranslate"><span class="pre">Updater</span></code> instance contains a message queue. All methods within the updater and the systems it uses (like e.g., <a class="reference external" href="https://travis-ci.org/TheAssassin/zsync2/">ZSync2</a>, which is one of the backends for the binary delta updates) add messages to this queue, which means that all kinds of status messages ever generated by any of the libraries will end up there.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Beware that this is a totally optional system, and it might not necessarily improve the user experience to show those messages. It is recommended to show them only in case of errors to help debugging. There is also no guarantee on the order of these messages.</p>
</div>
<p>All messages are preserved, so if they are not fetched, they might stack up. However, that shouldn’t be a problem really. Just make sure to clean up (<code class="code docutils literal notranslate"><span class="pre">delete</span></code>) your <code class="code docutils literal notranslate"><span class="pre">Updater</span></code> objects as soon as you don’t need them any more.</p>
<p>Let’s rewrite the update check code from above, with advanced error handling:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// check for update</span>
<span class="kt">bool</span> <span class="n">updateAvailable</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">updater</span><span class="p">.</span><span class="n">checkForChanges</span><span class="p">(</span><span class="n">updateAvailable</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// log status messages before exiting</span>

    <span class="c1">// nextStatusMessage will return true as long as there are status messages</span>
    <span class="c1">// by calling it in a loop as follows, all available messages will be fetched</span>
    <span class="n">string</span> <span class="n">nextMessage</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">updater</span><span class="p">.</span><span class="n">nextStatusMessage</span><span class="p">(</span><span class="n">nextMessage</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// imagine log() to do something meaningful</span>
        <span class="n">log</span><span class="p">(</span><span class="n">nextMessage</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// return error state</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">updateAvailable</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// perform update ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, in case the update check fails, the messages are logged.</p>
<p>At the moment, the update check is performed synchronously as it won’t take too long. This might be changed eventually, but now allows for running an update check without modifying the updater state.</p>
<p>Talking about updater states, the state is modified by running an update. As mentioned previously, updates are performed in their own thread automatically, using C++11 threading functionality. This allows for displaying progress, status messages etc. in a UI without any blocking issues or the need to run your own thread.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Important</strong>: Before actually performing an upgrade, it is recommended to check for updates first. The update check only performs reading IO, but a pointless update will create an entirely new file, even if it copies all the data from its predecessor.</p>
</div>
<p>Here’s some code how to run an update, and log progress and status messages until the update has finished:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">updater</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1">// isDone() returns true as soon as the update has finished</span>
<span class="c1">// error handling is performed later</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">updater</span><span class="p">.</span><span class="n">isDone</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// sleep for e.g., 100ms, to prevent 100% CPU usage</span>
    <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>

    <span class="kt">double</span> <span class="n">progress</span><span class="p">;</span>
    <span class="c1">// as with all methods, check for error</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">updater</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="n">progress</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">log</span><span class="p">(</span><span class="s">&quot;Call to progress() failed&quot;</span><span class="p">);</span>
        <span class="c1">// return error state</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// progress() returns a double between 0 and 1</span>
    <span class="c1">// you might have to scale its return value accordingly</span>
    <span class="c1">// this assumes that the progress bar expects a percentage</span>
    <span class="n">updateProgressBar</span><span class="p">(</span><span class="n">progress</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>

    <span class="c1">// fetch all status messages</span>
    <span class="c1">// this is basically the same as before</span>
    <span class="n">string</span> <span class="n">nextMessage</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">updater</span><span class="p">.</span><span class="n">nextStatusMessage</span><span class="p">(</span><span class="n">nextMessage</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">log</span><span class="p">(</span><span class="n">nextMessage</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you will have noticed, this code will just run until the update is done. However, there is no way to verify that the update actually worked. Therefore, you need to check for errors in the next step:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">updater</span><span class="p">.</span><span class="n">hasError</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">log</span><span class="p">(</span><span class="s">&quot;Error occurred. See previous messages for details.&quot;</span><span class="p">);</span>
    <span class="c1">// return error state</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As the background work has finished, and <code class="code docutils literal notranslate"><span class="pre">hasError()</span></code> itself doesn’t log any messages, all messages from the status message queue are displayed already, hence the note about checking the previous messages. It was mentioned previously that logging all messages might not be good for the user experience, so you could as well move the little loop fetching the messages to this error handler, and show a modal dialog containing all the messages issued during the update process. But this is up to you.</p>
<p>One last thing to notice is that AppImageUpdate by default takes the filename of the remote file for creating the updated AppImage file instead of overwriting the local file. This is done on purpose for several reasons. First, it might not be intended to overwrite previous versions of an AppImage, allowing to have different versions in parallel, or testing the current version versus the update that has just been downloaded.</p>
<p>This behavior implies the need for a method to actually fetch the path to this new file from the updater. This can be done as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>

<span class="n">string</span> <span class="n">pathToUpdatedFile</span><span class="p">;</span>

<span class="c1">// this method shouldn&#39;t fail at this point(1) any more</span>
<span class="c1">// but it&#39;s better to check for its return value to make sure everything&#39;s alright</span>
<span class="c1">// (1) when calling this before or while the update is running, the new path is not</span>
<span class="c1">// available, causing this method to return false, but we&#39;re past those points already</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">updater</span><span class="p">.</span><span class="n">pathToNewFile</span><span class="p">(</span><span class="n">pathToUpdatedFile</span><span class="p">))</span>

<span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Path to updated AppImage: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pathToUpdatedFile</span><span class="p">;</span>
<span class="n">log</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The updater takes care of putting the new file in the same directory as the previous one.</p>
</div>
<p>As you might not be interested in this feature, and probably don’t trust on remote filenames and choose your own ones when “installing” (well, downloading) AppImages to make it easier to find them again, you can override this feature. You can instantiate the <code class="code docutils literal notranslate"><span class="pre">Updater</span></code> object with an optional flag:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// constructor signature as of 2017/11/14:</span>
<span class="c1">// Updater::Updater(std::string path, bool overwrite = false);</span>

<span class="n">Updater</span> <span class="nf">updater</span><span class="p">(</span><span class="s">&quot;my.AppImage&quot;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, the updater will perform the update and move the new file to the original file’s location after successfully verifying the file integrity (and, as soon as it is implemented, validating the file’s signature, see <a class="reference external" href="https://github.com/AppImage/AppImageUpdate/issues/16">the related issue on GitHub</a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Important</strong>: The updater will never overwrite a file before all validation mechanisms report success.</p>
</div>
<p>ZSync2 based methods will furthermore always keep the old file as a backup. If the <code class="code docutils literal notranslate"><span class="pre">overwrite</span></code> flag is <code class="code docutils literal notranslate"><span class="pre">true</span></code>, the current file will be moved to <code class="code docutils literal notranslate"><span class="pre">my.AppImage.zs-old</span></code>. If it is <cite>false</cite>, the old file will remain untouched. Furthermore, if there is a file with the new filename, that file will be backed up with the <code class="code docutils literal notranslate"><span class="pre">.zs-old</span></code> suffix. This behavior is not ideal, the standalone UI has error handling code specific to this problem. This behavior is going to be subject of a GitHub issue soon. It is recommended to watch the discussion before implementing any code dealing with backups. Thad said, it is probably safe to check whether a <code class="code docutils literal notranslate"><span class="pre">.zs-old</span></code> file is created when using <code class="code docutils literal notranslate"><span class="pre">overwrite</span> <span class="pre">=</span> <span class="pre">true</span></code>, and delete it.</p>
</div>
</div>
</div>
</div>
<span id="document-packaging-guide/optional/signatures"></span><div class="section" id="signing-appimages">
<h4>Signing AppImages<a class="headerlink" href="#signing-appimages" title="Permalink to this headline">¶</a></h4>
<p>AppImages can be digitally signed by the person that has produced the AppImage. This ensures that the AppImage comes from the person who pretends to be the author, and ensures that the file has not been tampered with.</p>
<p>The AppImages specification allows the AppImage file to carry a digital signature built into the AppImages. This means that the signature does not need to be an external file, but can be carried inside the AppImage itself, similar to how signatures work for traditional Linux packages (such as <code class="code docutils literal notranslate"><span class="pre">.deb</span></code> or <code class="code docutils literal notranslate"><span class="pre">.rpm</span></code> files).</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#embedding-a-signature-inside-an-appimage" id="id2">Embedding a signature inside an AppImage</a></p></li>
<li><p><a class="reference internal" href="#reading-the-signature" id="id3">Reading the signature</a></p></li>
<li><p><a class="reference internal" href="#validating-the-signature" id="id4">Validating the signature</a></p></li>
</ul>
</div>
<div class="section" id="embedding-a-signature-inside-an-appimage">
<h5><a class="toc-backref" href="#id2">Embedding a signature inside an AppImage</a><a class="headerlink" href="#embedding-a-signature-inside-an-appimage" title="Permalink to this headline">¶</a></h5>
<p>While it would be possible to embed signatures manually, the easiest way to produce a digitally signed AppImage is to use the <code class="code docutils literal notranslate"><span class="pre">appimagetool</span></code> command line tool. The internally uses <code class="code docutils literal notranslate"><span class="pre">gpg</span></code> or <code class="code docutils literal notranslate"><span class="pre">gpg2</span></code> if it is installed and configured on the system.</p>
<p>Especially, a key for signing must be prepared before AppImages can be signed. If the machine on which the AppImage is being generated does not have a valid signing key yet, a new one can be generated using</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gpg2 --full-gen-key
</pre></div>
</div>
<p>Please refer to the <code class="code docutils literal notranslate"><span class="pre">gpg</span></code> or <code class="code docutils literal notranslate"><span class="pre">gpg2</span></code> documentation for additional information. You should take additional care to backup your private and public keys in a secure location.</p>
<p>Once you’re signing keys have been set up, you can sign AppImages at AppImage creation time using</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ./appimagetool-x86_64.AppImage some.AppDir --sign
</pre></div>
</div>
<p>This will sign the AppImage with <code class="code docutils literal notranslate"><span class="pre">gpg[2]</span></code> and will put the signature into the AppImage.</p>
</div>
<div class="section" id="reading-the-signature">
<h5><a class="toc-backref" href="#id3">Reading the signature</a><a class="headerlink" href="#reading-the-signature" title="Permalink to this headline">¶</a></h5>
<p>You can display the digital signature that is embedded in AppImage by running the AppImage with the <code class="code docutils literal notranslate"><span class="pre">--appimage-signature</span></code> option like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ./XChat_IRC-x86_64.AppImage --appimage-signature

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQEcBAABCAAGBQJX6CN9AAoJENBdKWeGw9/dsvoH/RgEggMiNTwgyA4io2Dyy1j1
6U3CQST9HVmh9PjeFKZCgFCZbHvpFz9mzhLTPlOAbczBnSmmbgqROINaLW+1tqEx
stOy67D3Z1cySzRTOhSkjiUOP5unmZL6QTNPxRHmuRkyihv7YfAlkrogXQlYbZ1h
Ilt6jU1b97GSPox/EE3Z002iZGJYQ3FfjAlp9o947goY5koA5KYqyzTCvEjhTk/L
wz1mFcjEkzHt9CaHZfrZCE3QVSBTq071wzsHCFHaJswPhA6iI0psCnFY56PPResi
uljTQr3nOBaqNyUgU3y4Tbd+36cwggSaTpGAzlhgNoalIwB1ltFSdPeRPe4Q3Qc<span class="o">=</span>
<span class="o">=</span>MR0w
-----END PGP SIGNATURE-----
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please note that while this displays the signature, it does not validate the signature. In other words, this does not tell you whether the signature is valid or not, or whether the file has been tampered with or not. To validate the signature, an external tool (which is not part of AppImage that needs to be validated) needs to be used.</p>
</div>
</div>
<div class="section" id="validating-the-signature">
<h5><a class="toc-backref" href="#id4">Validating the signature</a><a class="headerlink" href="#validating-the-signature" title="Permalink to this headline">¶</a></h5>
<p>To validate a signature of an an AppImage and to determine whether an AppImage has been compromised, an external tool needs to be used. There is a very simple tool called <code class="code docutils literal notranslate"><span class="pre">validate</span></code> that can do this.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ chmod a+x ./validate
$ ./validate ./XChat_IRC-x86_64.AppImage

gpg: Signature made Sun <span class="m">25</span> Sep <span class="m">2016</span> <span class="m">10</span>:41:24 PM CEST using RSA key ID 86C3DFDD
gpg: Good signature from <span class="s2">&quot;Testkey&quot;</span> <span class="o">[</span>ultimate<span class="o">]</span>
</pre></div>
</div>
<p>Signature validation can also be integrated into higher level software such as the optional <code class="code docutils literal notranslate"><span class="pre">appimaged</span></code> demon and/or <code class="code docutils literal notranslate"><span class="pre">AppImageUpdate</span></code>. For example the <code class="code docutils literal notranslate"><span class="pre">appimaged</span></code> daemon may decide to run applications without a valid signature in a confined sandbox in the future, if the system is set up accordingly.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>It may be desirable to integrate validate functionality into <code class="code docutils literal notranslate"><span class="pre">libappimage</span></code> and into tools like <code class="code docutils literal notranslate"><span class="pre">appimagetool</span></code>, the optional <code class="code docutils literal notranslate"><span class="pre">appimaged</span></code> demon and/or <code class="code docutils literal notranslate"><span class="pre">AppImageUpdate</span></code>.</p>
</div>
</div>
</div>
<span id="document-packaging-guide/optional/appstream"></span><div class="section" id="appstream-metadata">
<span id="ref-appstream"></span><h4>AppStream metadata<a class="headerlink" href="#appstream-metadata" title="Permalink to this headline">¶</a></h4>
<p>AppStream is a cross-distribution effort for providing metadata for software in the (Linux) ecosystem.
It provides a convenient way to get information about not installed software,
and is one of the building blocks for software centers.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#why-should-i-include-appstream-metadata-in-my-appimage" id="id1">Why should I include AppStream metadata in my AppImage?</a></p></li>
<li><p><a class="reference internal" href="#using-the-appstream-generator" id="id2">Using the AppStream generator</a></p></li>
<li><p><a class="reference internal" href="#embedding-the-appstream-metadata" id="id3">Embedding the AppStream metadata</a></p></li>
</ul>
</div>
<div class="section" id="why-should-i-include-appstream-metadata-in-my-appimage">
<h5><a class="toc-backref" href="#id1">Why should I include AppStream metadata in my AppImage?</a><a class="headerlink" href="#why-should-i-include-appstream-metadata-in-my-appimage" title="Permalink to this headline">¶</a></h5>
<p>Desktop environments, file managers, AppImage catalogs, software centers, and app stores can use metadata about the application from inside the AppImage to get a description, URLs, screenshots, and other information that describes the application. This optional metadata travels inside the AppImage.</p>
<p>So if you would like your application to show a nice screenshot in app centers, you should add an AppStream metainfo file to your AppImage. AppStream is a format that exists independently of AppImage and can be used in conjunction with other packaging formats as well. Many open source applications already come with AppStream metainfo files by default.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>More information on AppStream can be found on the <a class="reference external" href="https://www.freedesktop.org/software/appstream/docs/chap-Quickstart.html#sect-Quickstart-DesktopApps">FreeDesktop.org pages</a>.</p>
</div>
</div>
<div class="section" id="using-the-appstream-generator">
<h5><a class="toc-backref" href="#id2">Using the AppStream generator</a><a class="headerlink" href="#using-the-appstream-generator" title="Permalink to this headline">¶</a></h5>
<p>An easy way to generate an AppStream metainfo file is to use the online generator at <a class="reference external" href="http://output.jsbin.com/qoqukof">http://output.jsbin.com/qoqukof</a>.</p>
</div>
<div class="section" id="embedding-the-appstream-metadata">
<h5><a class="toc-backref" href="#id3">Embedding the AppStream metadata</a><a class="headerlink" href="#embedding-the-appstream-metadata" title="Permalink to this headline">¶</a></h5>
<p>Once you have generated a suitable AppStream metainfo file, place it into <code class="code docutils literal notranslate"><span class="pre">usr/share/metainfo/myapp.appdata.xml</span></code> in your AppDir, and generate an AppImage from it. It is generally a good idea to check AppStream metainfo files for errors using the <code class="code docutils literal notranslate"><span class="pre">appstreamcli</span></code> and/or <code class="code docutils literal notranslate"><span class="pre">appstream-util</span></code> command line tools. <code class="code docutils literal notranslate"><span class="pre">appimagetool</span></code> will automatically attempt to validate the AppStream metainfo file if <code class="code docutils literal notranslate"><span class="pre">appstreamcli</span></code> and/or <code class="code docutils literal notranslate"><span class="pre">appstream-util</span></code> are available on the <code class="code docutils literal notranslate"><span class="pre">$PATH</span></code>.</p>
</div>
</div>
</div>
</div>
<span id="document-packaging-guide/hosted-services/index"></span><div class="section" id="hosted-services">
<span id="ref-hosted-services"></span><h3>Hosted services<a class="headerlink" href="#hosted-services" title="Permalink to this headline">¶</a></h3>
<p>There’s some hosted services which can help with building AppImages. These services are described in the following section.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The services listed in this section is not exclusive. Many other services, especially generic CI services, can be used to build AppImages. The following services just have been tested and are known to work. For some of them, there’s some example scripts, etc.</p>
</div>
<div class="toctree-wrapper compound">
<span id="document-packaging-guide/hosted-services/travis-ci"></span><div class="section" id="bundling-your-travis-ci-builds-as-appimages">
<span id="ref-travis-ci"></span><h4>Bundling your Travis CI builds as AppImages<a class="headerlink" href="#bundling-your-travis-ci-builds-as-appimages" title="Permalink to this headline">¶</a></h4>
<p>Services such as Travis CI make it easy to build software automatically whenever a new commit is pushed to the source code repository. How you turn your build products into an AppImage depends on how your application is built. Generally there are two main methods, namely <a class="reference internal" href="index.html#ref-manual"><span class="std std-ref">producing an application directory</span></a>, and using <a class="reference internal" href="index.html#ref-packaging-from-source"><span class="std std-ref">tools to automate the process</span></a>.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#producing-an-application-directory-using-bash-scripts" id="id2">Producing an application directory using bash scripts</a></p></li>
<li><p><a class="reference internal" href="#producing-an-application-directory-using-linuxdeploy" id="id3">Producing an application directory using linuxdeploy</a></p></li>
<li><p><a class="reference internal" href="#uploading-the-generated-appimage" id="id4">Uploading the generated AppImage</a></p></li>
</ul>
</div>
<div class="section" id="producing-an-application-directory-using-bash-scripts">
<h5><a class="toc-backref" href="#id2">Producing an application directory using bash scripts</a><a class="headerlink" href="#producing-an-application-directory-using-bash-scripts" title="Permalink to this headline">¶</a></h5>
<p>Some types of applications can best be converted into application directories using custom bash script. However, to facilitate this, there is a collection of convenience functions in <a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/master/functions.sh">https://github.com/AppImage/pkg2appimage/blob/master/functions.sh</a> which can use in your own scripts.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Document the functions in <code class="code docutils literal notranslate"><span class="pre">functions.sh</span></code> that are for public consumption based on comments in the file.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For most types of applications, especially those compiled with compilers such as <code class="code docutils literal notranslate"><span class="pre">gcc</span></code> or <code class="code docutils literal notranslate"><span class="pre">g++</span></code> using a tool like <a class="reference internal" href="index.html#ref-linuxdeploy"><span class="std std-ref">linuxdeploy user guide</span></a> is much easier than doing this in a bash script because it automates much of the process.</p>
</div>
</div>
<div class="section" id="producing-an-application-directory-using-linuxdeploy">
<h5><a class="toc-backref" href="#id3">Producing an application directory using linuxdeploy</a><a class="headerlink" href="#producing-an-application-directory-using-linuxdeploy" title="Permalink to this headline">¶</a></h5>
<p>Please refer to the chapter <a class="reference internal" href="index.html#ref-packaging-from-source"><span class="std std-ref">Packaging from source</span></a>.</p>
<p>For general information on linuxdeploy, see <a class="reference internal" href="index.html#ref-linuxdeploy"><span class="std std-ref">linuxdeploy user guide</span></a>.</p>
</div>
<div class="section" id="uploading-the-generated-appimage">
<span id="ref-uploadtool"></span><h5><a class="toc-backref" href="#id4">Uploading the generated AppImage</a><a class="headerlink" href="#uploading-the-generated-appimage" title="Permalink to this headline">¶</a></h5>
<p>Once an Appimage has been generated, you want to upload it to GitHub Releases. For this, you can use the <code class="code docutils literal notranslate"><span class="pre">upload.sh</span></code> script available in the <a class="reference external" href="uploadtool-github">uploadtool repository on GitHub</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is best practice to upload binaries (such as AppImages) to GitHub Releases rather than committing them into the repository itself.</p>
</div>
<p>Super simple uploading of continuous builds (each push) to GitHub Releases. If this is not the easiest way to upload continuous builds to GitHub Releases, then it is a bug.</p>
<div class="section" id="using-upload-sh">
<h6>Using <code class="docutils literal notranslate"><span class="pre">upload.sh</span></code><a class="headerlink" href="#using-upload-sh" title="Permalink to this headline">¶</a></h6>
<p>The <code class="code docutils literal notranslate"><span class="pre">upload.sh</span></code> script in the <a class="reference external" href="uploadtool-github">uploadtool repository</a> is designed to be called from Travis CI after a successful build. By default, this script will <em>delete</em> any pre-existing release tagged with <code class="code docutils literal notranslate"><span class="pre">continuous</span></code>, tag the current state with the name <code class="code docutils literal notranslate"><span class="pre">continuous</span></code>, create a new release with that name, and upload the specified binaries there. For pull requests, it will upload the binaries to transfer.sh instead and post the resulting download URL to the pull request page on GitHub.</p>
<ul class="simple">
<li><p>On <a class="reference external" href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>, click on “Generate new token” and generate a token with at least the <code class="code docutils literal notranslate"><span class="pre">public_repo</span></code>, <code class="code docutils literal notranslate"><span class="pre">repo:status</span></code>, and <code class="code docutils literal notranslate"><span class="pre">repo_deployment</span></code> scopes</p></li>
<li><p>On Travis CI, go to the settings of your project at <code class="code docutils literal notranslate"><span class="pre">https://travis-ci.org/yourusername/yourrepository/settings</span></code></p></li>
<li><p>Under “Environment Variables”, add key <code class="code docutils literal notranslate"><span class="pre">GITHUB_TOKEN</span></code> and the token you generated above as the value. <strong>Make sure that “Display value in build log” is set to “OFF”!</strong></p></li>
<li><p>In the <code class="code docutils literal notranslate"><span class="pre">.travis.yml</span></code> of your GitHub repository, add something like this (assuming the build artifacts to be uploaded are in out/):</p></li>
</ul>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">after_success</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">ls -lh out/*</span> <span class="c1"># Assuming you have some files in out/ that you would like to upload</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">wget -c https://github.com/probonopd/uploadtool/raw/master/upload.sh</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">bash upload.sh out/*</span>

<span class="nt">branches</span><span class="p">:</span>
  <span class="nt">except</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="c1"># Do not build tags that we create when we upload to GitHub Releases</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">/^(?i:continuous)$/</span>
</pre></div>
</div>
<div class="section" id="environment-variables">
<h7>Environment variables<a class="headerlink" href="#environment-variables" title="Permalink to this headline">¶</a></h7>
<p><code class="code docutils literal notranslate"><span class="pre">upload.sh</span></code> normally only creates one stream of continuous releases for the latest commits that are pushed into (or merged into) the repository.</p>
<p>It’s possible to use <code class="code docutils literal notranslate"><span class="pre">upload.sh</span></code> in a more complex manner by setting the environment variable <code class="code docutils literal notranslate"><span class="pre">UPLOADTOOL_SUFFIX</span></code>. If this variable is set to the name of the current tag, then <code class="code docutils literal notranslate"><span class="pre">upload.sh</span></code> will upload a release to the repository (basically reproducing the <code class="code docutils literal notranslate"><span class="pre">deploy:</span></code> feature in <code class="code docutils literal notranslate"><span class="pre">.travis.yml</span></code>).</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">UPLOADTOOL_SUFFIX</span></code> is set to a different text, then this text is used as suffix for the <code class="code docutils literal notranslate"><span class="pre">continuous</span></code> tag that is created for continuous releases. This way, a project can customize what releases are being created.</p>
<p>One possible use case for this is to set up continuous builds for feature or test branches:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">[</span> ! -z <span class="nv">$TRAVIS_BRANCH</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$TRAVIS_BRANCH</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;master&quot;</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
    <span class="nb">export</span> <span class="nv">UPLOADTOOL_SUFFIX</span><span class="o">=</span><span class="nv">$TRAVIS_BRANCH</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>This will create builds tagged with <code class="code docutils literal notranslate"><span class="pre">continuous</span></code> for pushes/merges to <code class="code docutils literal notranslate"><span class="pre">master</span></code> and with <code class="code docutils literal notranslate"><span class="pre">continuous-&lt;branch-name&gt;</span></code> for pushes / merges to other branches.</p>
<p>The two environment variables <code class="code docutils literal notranslate"><span class="pre">UPLOADTOOL_PR_BODY</span></code> and <code class="code docutils literal notranslate"><span class="pre">UPLOADTOOL_BODY</span></code> allow the calling script to customize the messages that are posted either for pull requests or merges/pushes. If these variables aren’t set, generic default texts are used.</p>
</div>
</div>
</div>
</div>
<span id="document-packaging-guide/hosted-services/opensuse-build-service"></span><div class="section" id="using-the-open-build-service">
<span id="ref-obs"></span><h4>Using the Open Build Service<a class="headerlink" href="#using-the-open-build-service" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://openbuildservice.org/">Open Build Service</a> is a generic system to build and distribute packages from sources in an automatic, consistent and reproducible way. It allows you to build software for various package formats and distributions. Now it can also build AppImages that run on a variety of distributions.</p>
<p>The <a class="reference external" href="https://build.opensuse.org/">openSUSE Build Service</a> is the public instance of the Open Build Service (OBS). This infrastructure can can be used for free by open source projects. However, you are not limited to it - you can set up your own Open Build Service instance if you like.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#differences-to-other-methods-of-building-appimages" id="id2">Differences to other methods of building AppImages</a></p></li>
<li><p><a class="reference internal" href="#the-osc-command-line-tool" id="id3">The osc command line tool</a></p></li>
<li><p><a class="reference internal" href="#setting-up-an-account-and-a-project" id="id4">Setting up an account and a project</a></p></li>
<li><p><a class="reference internal" href="#appimage-yml-file" id="id5"><cite>appimage.yml</cite> file</a></p></li>
<li><p><a class="reference internal" href="#inspecting-the-results" id="id6">Inspecting the results</a></p></li>
<li><p><a class="reference internal" href="#working-examples" id="id7">Working examples</a></p></li>
<li><p><a class="reference internal" href="#continuous-builds-with-github-and-obs" id="id8">Continuous builds with GitHub and OBS</a></p></li>
</ul>
</div>
<div class="section" id="differences-to-other-methods-of-building-appimages">
<h5><a class="toc-backref" href="#id2">Differences to other methods of building AppImages</a><a class="headerlink" href="#differences-to-other-methods-of-building-appimages" title="Permalink to this headline">¶</a></h5>
<p>There are different ways to build AppImages. Why is using Open Build Service interesting?</p>
<ul class="simple">
<li><p>If you are already using Open Build Service, then <em>also</em> generating an AppImage should be straightforward</p></li>
<li><p>You can use the public <a class="reference external" href="https://build.opensuse.org/">openSUSE Build Service</a> instance and use the existing infrastructure to build and distribute your AppImage (for open source projects only)</p></li>
<li><p>You can build AppImages in “automatic, consistent and reproducible way”. This means that unlike when you build your AppImages on, e.g., Travis CI, where you can pull in arbitrarily changing build dependencies and AppImage ingredients from the net, your builds on Open Build Service can only use build dependencies and AppImage ingredients that have their source code in distribution repositories or on Open Build Service. While this may be a limitation in some cases (e.g., for agile/continuous builds), it means that the build result is much more reproducible</p></li>
<li><p>OBS helps you to keep the ingredients of your AppImage up-to-date all the time using proven distribution methodologies and tool, relieving the person or group providing AppImages from manual work as discussed <a class="reference external" href="https://www.youtube.com/watch?v=BrWB2OZ9h2Y">here</a></p></li>
<li><p>OBS automatically builds a new AppImage for you if one if its ingredients is updated on OBS</p></li>
<li><p>OBS automatically signs AppImages using the user’s key on OBS</p></li>
<li><p>OBS automatically embeds update information into AppImages to enable binary delta updates using AppImageUpdate. This means that if in a 100 MB AppImage only 1 MB changed between versions, then the user has to download only 1 MB rather than 100 MB</p></li>
</ul>
</div>
<div class="section" id="the-osc-command-line-tool">
<h5><a class="toc-backref" href="#id3">The osc command line tool</a><a class="headerlink" href="#the-osc-command-line-tool" title="Permalink to this headline">¶</a></h5>
<p>While OBS can be used entirely through the web interface, it can be beneficial to use the <cite>osc</cite> command line tool. It is available as an AppImage from <a class="reference external" href="https://download.opensuse.org/repositories/openSUSE:/Tools/AppImage/">OpenSUSE’s download page</a>. Since this page is mainly geared toward beginners, it mainly describes the web interface. However, using the command line tool may offer a quicker route for more experienced OBS users.</p>
</div>
<div class="section" id="setting-up-an-account-and-a-project">
<h5><a class="toc-backref" href="#id4">Setting up an account and a project</a><a class="headerlink" href="#setting-up-an-account-and-a-project" title="Permalink to this headline">¶</a></h5>
<p>This page describes how to use the public <a class="reference external" href="https://build.opensuse.org/">openSUSE Build Service</a> instance. If you use your own instance, things will probably be similar but may not be identical.</p>
<ul class="simple">
<li><p>To set up an account, go to <a class="reference external" href="https://build.opensuse.org/">https://build.opensuse.org/</a> and click on “Sign Up” in the upper-right corner</p></li>
<li><p>Once you have an account, log in using it and click on “Home Project” in the upper-right corner. Every user has a home project. Think if it as a collection of source code packages that you build AppImages (and possibly other types of packages) from. Later on, you can add additional projects, and invite collaborators to them</p></li>
</ul>
<div class="section" id="hello-world">
<h6>Hello world<a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h6>
<p>On the <a class="reference external" href="https://build.opensuse.org/">https://build.opensuse.org/</a> homepage, click on “New Image”.</p>
<img alt="&quot;New Image&quot; icon" src="_images/obs-new-image.png" />
<p>Then select AppImage, and click “Create Appliance”.</p>
<img alt="Radio button: &quot;Select template&quot; (AppImage), input field: &quot;Name your appliance&quot;, submit button: &quot;Create Appliance&quot;" src="_images/obs-create-appliance.png" />
<p>Done! An AppImage of Leafpad, a simple text editor, will be built. You can use this template as a starting point to customize for other applications.</p>
<p>The following sections describe how to do the same manually.</p>
</div>
<div class="section" id="setting-up-an-appimage-target-for-the-project">
<h6>Setting up an AppImage target for the project<a class="headerlink" href="#setting-up-an-appimage-target-for-the-project" title="Permalink to this headline">¶</a></h6>
<p>You need to tell OBS that for all source code packages in your home project you want to generate AppImages. To enable a target for AppImage, you can either use the command line tool <code class="code docutils literal notranslate"><span class="pre">osc</span> <span class="pre">meta</span> <span class="pre">prj</span> <span class="pre">-e</span> <span class="pre">...</span></code> or use the OBS web interface:</p>
<ul class="simple">
<li><p>Go to your home project</p></li>
<li><p>Click on “Advanced”</p></li>
<li><p>Click on “Meta”</p></li>
<li><p>Copy and paste the <code class="code docutils literal notranslate"><span class="pre">&lt;repository&gt;</span></code> tags from the following:</p></li>
</ul>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;project</span> <span class="na">name=</span><span class="s">&quot;home:probono&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;title&gt;</span>probono<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;description/&gt;</span>
  <span class="nt">&lt;person</span> <span class="na">userid=</span><span class="s">&quot;probono&quot;</span> <span class="na">role=</span><span class="s">&quot;maintainer&quot;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;publish&gt;</span>
    <span class="nt">&lt;enable/&gt;</span>
    <span class="nt">&lt;/publish&gt;</span>
  <span class="nt">&lt;repository</span> <span class="na">name=</span><span class="s">&quot;AppImage.arm&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;path</span> <span class="na">project=</span><span class="s">&quot;home:probono&quot;</span> <span class="na">repository=</span><span class="s">&quot;openSUSE_13.1&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;path</span> <span class="na">project=</span><span class="s">&quot;OBS:AppImage&quot;</span> <span class="na">repository=</span><span class="s">&quot;AppImage.arm&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;arch&gt;</span>armv7l<span class="nt">&lt;/arch&gt;</span>
    <span class="nt">&lt;arch&gt;</span>aarch64<span class="nt">&lt;/arch&gt;</span>
  <span class="nt">&lt;/repository&gt;</span>
  <span class="nt">&lt;repository</span> <span class="na">name=</span><span class="s">&quot;AppImage&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;path</span> <span class="na">project=</span><span class="s">&quot;home:probono&quot;</span> <span class="na">repository=</span><span class="s">&quot;openSUSE_13.1&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;path</span> <span class="na">project=</span><span class="s">&quot;OBS:AppImage&quot;</span> <span class="na">repository=</span><span class="s">&quot;AppImage&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;arch&gt;</span>x86_64<span class="nt">&lt;/arch&gt;</span>
    <span class="nt">&lt;arch&gt;</span>i586<span class="nt">&lt;/arch&gt;</span>
  <span class="nt">&lt;/repository&gt;</span>
<span class="nt">&lt;/project&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">AppImage.arm</span></code> repository is used for the ARM architectures for now. This will possibly change in the future.</p>
</div>
<p>Be sure to just insert the <code class="code docutils literal notranslate"><span class="pre">&lt;repository&gt;</span></code> tags into your existing file. For AppImage, we need to select one of the build targets that is built in your obs project. In the example above, please make sure to replace <code class="code docutils literal notranslate"><span class="pre">home:probono</span></code> with the actual name of the obs project where <code class="code docutils literal notranslate"><span class="pre">appimage.yml</span></code> should look for its resources - this can be the current project, and even RPMs created by the same package work as resources for AppImage.</p>
<p>Also check if openSUSE_13.1 is still alive or use something slightly newer instead.</p>
</div>
<div class="section" id="use-native-appimage-build-support">
<h6>Use native AppImage build support<a class="headerlink" href="#use-native-appimage-build-support" title="Permalink to this headline">¶</a></h6>
<p>In order to build an AppImage you need to provide a file called <code class="code docutils literal notranslate"><span class="pre">appimage.yml</span></code>. OBS needs to get all the required resources before building. This is needed in order to be able to track changes and to find out whether a rebuild is needed, and to provide the resources in a secured and reproducible environment without network access.</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">build:</span></code> section can be used to define resources which are required to build. This can be binary packages (currently only rpm) or URLs to any other source control management systems or file. The binary packages listed in the build section get installed to the build  environment, but not extracted into the AppDir.</p>
<p>The packages listed in the ingredients section do not get installed into the build environment but get extracted into the AppDir.</p>
<p>URLs for the supported source control management systems (git, svn, cvs, hg, bzr) get handled via the appimage source service, which is a part of <a class="reference external" href="https://github.com/openSUSE/obs-service-tar_scm">obs-service-tar_scm</a>. It is downloading the sources and provides them to the build system as directory structure.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p><strong>not yet implemented</strong>
URLs to files get handled via the download_files source service. It is handy to provide single files to the build.</p>
</div>
<p>Scripts can be executed in the form of the script hooks of the <code class="code docutils literal notranslate"><span class="pre">appimage.yml</span></code> file.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">Recipe</span></code> files are <strong>not</strong> supported, anything they can do can be done inside the <code class="code docutils literal notranslate"><span class="pre">script</span></code> sections of <code class="code docutils literal notranslate"><span class="pre">appimage.yml</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is optional to either</p>
</div>
</div>
<ul class="simple">
<li><p>create the AppImage root via packages by using the ingredients section. This is useful especially for larger software, because it avoid the need of a recompilation and just repackages the content of binary packages.</p></li>
<li><p>create the AppImage root only from source using the scripts. This is useful when you want to avoid to build a binary package first.</p></li>
</ul>
<p>Both approaches can also get combined if wanted.</p>
</div>
</div>
<div class="section" id="appimage-yml-file">
<h5><a class="toc-backref" href="#id5"><cite>appimage.yml</cite> file</a><a class="headerlink" href="#appimage-yml-file" title="Permalink to this headline">¶</a></h5>
<p>Please note that it uses the following environment variables which are provided by the build system:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">BUILD_SOURCE_DIR</span></code>: The absolute directory name where all source files or directories are hosted</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">BUILD_APPDIR</span></code>: The directory which will get packaged as AppImage file</p></li>
</ul>
<div class="section" id="most-simple-example">
<h6>Most simple example<a class="headerlink" href="#most-simple-example" title="Permalink to this headline">¶</a></h6>
<p>This <code class="code docutils literal notranslate"><span class="pre">APPIMAGE_NAME</span></code> application will get package into an <code class="code docutils literal notranslate"><span class="pre">.AppImage</span></code> file just by installing the <code class="code docutils literal notranslate"><span class="pre">RPM_PACKAGE_NAME</span></code>. The binary can get patched automatically when using the <code class="code docutils literal notranslate"><span class="pre">binpatch:</span> <span class="pre">true</span></code> option</p>
<p><img alt="question" src="_images/question.png" /> From which repositories can rpms be installed? Only my own or those of all OBS users?</p>
<p><img alt="question" src="_images/question.png" /> Can additional repositories be added?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>app: APPIMAGE_NAME
binpatch: true

ingredients:
  packages:
    - RPM_PACKAGE_NAME

script:
  - cd $BUILD_APPDIR/
  - cp $BUILD_APPDIR/usr/share/applications/NAME.desktop $BUILD_APPDIR
  - cp $BUILD_APPDIR/usr/share/pixmaps/NAME.png $BUILD_APPDIR
</pre></div>
</div>
</div>
<div class="section" id="simple-example-building-from-source">
<h6>Simple example building from source<a class="headerlink" href="#simple-example-building-from-source" title="Permalink to this headline">¶</a></h6>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>app: QtQuickApp

build:
  packages:
    - linuxdeployqt
    - pkgconfig(Qt5Quick)
  git:
    - https://github.com/probonopd/QtQuickApp.git

script:
  - cd $BUILD_SOURCE_DIR/QtQuickApp*
  - qmake-qt5 PREFIX=/usr
  - make INSTALL_ROOT=$BUILD_APPDIR install
  - unset QTDIR; unset QT_PLUGIN_PATH ; unset LD_LIBRARY_PATH
  - linuxdeployqt $BUILD_APPDIR/usr/share/applications/*.desktop -qmldir=$BUILD_SOURCE_DIR/ -bundle-non-qt-libs -verbose=2
  - linuxdeployqt $BUILD_APPDIR/usr/share/applications/*.desktop -qmldir=$BUILD_SOURCE_DIR/ -bundle-non-qt-libs -verbose=2
</pre></div>
</div>
<p>We have to also upload a file called <code class="code docutils literal notranslate"><span class="pre">_service</span></code> containing</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;services&gt;</span>
  <span class="nt">&lt;service</span> <span class="na">name=</span><span class="s">&quot;appimage&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/services&gt;</span>
</pre></div>
</div>
<p>When trying this on a private OBS instance, please make sure to have <code class="code docutils literal notranslate"><span class="pre">obs-service-appimage</span></code> installed. This can be done e.g. on a Leap 42.1 machine with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zypper</span> <span class="n">addrepo</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">download</span><span class="o">.</span><span class="n">opensuse</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">repositories</span><span class="o">/</span><span class="n">openSUSE</span><span class="p">:</span><span class="n">Tools</span><span class="o">/</span><span class="n">openSUSE_42</span><span class="o">.</span><span class="mi">1</span><span class="o">/</span><span class="n">openSUSE</span><span class="p">:</span><span class="n">Tools</span><span class="o">.</span><span class="n">repo</span>
<span class="n">zypper</span> <span class="n">ref</span>
<span class="n">zypper</span> <span class="ow">in</span> <span class="n">obs</span><span class="o">-</span><span class="n">service</span><span class="o">-</span><span class="n">appimage</span>
</pre></div>
</div>
<div class="section" id="options-inside-of-the-build-section">
<h7>Options inside of the build section<a class="headerlink" href="#options-inside-of-the-build-section" title="Permalink to this headline">¶</a></h7>
<p>you can add multiple items in the sections.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">build</span><span class="p">:</span>
  <span class="n">packages</span><span class="p">:</span>
     <span class="o">-</span> <span class="p">[</span><span class="n">SINGLE</span> <span class="n">BINARY</span> <span class="n">PACKAGE</span> <span class="n">NAME</span><span class="p">]</span>

  <span class="n">git</span><span class="p">:</span>   <span class="c1"># can be also svn, cvs, hg, bzr</span>
     <span class="o">-</span> <span class="p">[</span><span class="n">URL</span> <span class="n">TO</span> <span class="n">SCM</span> <span class="n">REPOSITORY</span><span class="p">]</span>

  <span class="n">files</span><span class="p">:</span>
     <span class="o">-</span> <span class="p">[</span><span class="n">URL</span> <span class="n">TO</span> <span class="n">A</span> <span class="n">RESOURCE</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="inspecting-the-results">
<h5><a class="toc-backref" href="#id6">Inspecting the results</a><a class="headerlink" href="#inspecting-the-results" title="Permalink to this headline">¶</a></h5>
<p>Be sure to download the resulting AppImage from OBS and test it on your target system(s). It is recommended to test at least on the oldest still-supported Ubuntu LTS, the recent Ubuntu, the oldest still-supported openSUSE Leap, possibly he latest openSUSE Tumbleweed, CentOS 7, and the latest Fedora release (although you may to choose to support different target systems).</p>
</div>
<div class="section" id="working-examples">
<h5><a class="toc-backref" href="#id7">Working examples</a><a class="headerlink" href="#working-examples" title="Permalink to this headline">¶</a></h5>
<p>Feel free to put yours here, too.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://build.opensuse.org/package/show/home:probono/QtQuickApp?repository=AppImage">https://build.opensuse.org/package/show/home:probono/QtQuickApp?repository=AppImage</a></p></li>
<li><p><a class="reference external" href="https://build.opensuse.org/package/show/home:probono/DSRemote?repository=AppImage">https://build.opensuse.org/package/show/home:probono/DSRemote?repository=AppImage</a></p></li>
<li><p><a class="reference external" href="https://build.opensuse.org/package/show/home:probono/Qactus?repository=AppImage">https://build.opensuse.org/package/show/home:probono/Qactus?repository=AppImage</a></p></li>
<li><p><a class="reference external" href="https://build.opensuse.org/package/show/home:probono/leafpad?repository=AppImage">https://build.opensuse.org/package/show/home:probono/leafpad?repository=AppImage</a></p></li>
<li><p><a class="reference external" href="https://github.com/olav-st/screencloud/blob/master/deploy/linux/appimage.yml">https://github.com/olav-st/screencloud/blob/master/deploy/linux/appimage.yml</a></p></li>
<li><p><a class="reference external" href="https://build.opensuse.org/package/view_file/home:pbek:QOwnNotes/desktop/appimage.yml?expand=1">https://build.opensuse.org/package/view_file/home:pbek:QOwnNotes/desktop/appimage.yml?expand=1</a></p></li>
<li><p><a class="reference external" href="https://build.opensuse.org/package/view_file/home:pbartfai/LDView/_service:extract_file:appimage.yml?expand=1">https://build.opensuse.org/package/view_file/home:pbartfai/LDView/_service:extract_file:appimage.yml?expand=1</a></p></li>
<li><p><a class="reference external" href="https://build.opensuse.org/package/view_file/home:lachs0r:taisei/taisei/appimage.yml?expand=1">https://build.opensuse.org/package/view_file/home:lachs0r:taisei/taisei/appimage.yml?expand=1</a></p></li>
</ul>
</div>
<div class="section" id="continuous-builds-with-github-and-obs">
<h5><a class="toc-backref" href="#id8">Continuous builds with GitHub and OBS</a><a class="headerlink" href="#continuous-builds-with-github-and-obs" title="Permalink to this headline">¶</a></h5>
<p>If your source code lives on GitHub, then you can set up a mechanism that makes GitHub inform OBS about any changes to the source code, and trigger a rebuild automatically.</p>
<p>A token needs to be generated, this can be done using the <code class="code docutils literal notranslate"><span class="pre">osc</span></code> OBS command line client:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo apt update <span class="o">&amp;&amp;</span> sudo apt install osc <span class="c1"># or your package manager&#39;s equivalent</span>
osc token --create
</pre></div>
</div>
<p>If you have already generated a token in the past, you can show it with</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>osc token
</pre></div>
</div>
<p>On the GitHub project page, click on “Settings”, then click on “Integrations &amp; services”, then click on “Add service”, enter “Obs” and select it. For example, for the <a class="reference external" href="https://github.com/probonopd/QtQuickApp/">QtQuickApp</a> project go to <code class="code docutils literal notranslate"><span class="pre">https://github.com/probonopd/QtQuickApp/settings/installations</span></code>, and corresponding to <a class="reference external" href="https://build.opensuse.org/package/show/home:probono/QtQuickApp">https://build.opensuse.org/package/show/home:probono/QtQuickApp</a> entered <code class="code docutils literal notranslate"><span class="pre">home:probono</span></code> for the project and <code class="code docutils literal notranslate"><span class="pre">QtQuickApp</span></code> for in the Package field, as well as the token generated above in the “Token” field. Please note that you need to supply your own username and project name instead of the one in the example above.</p>
<p>Now, whenever you do a <code class="code docutils literal notranslate"><span class="pre">git</span> <span class="pre">push</span></code> to my <a class="reference external" href="https://github.com/probonopd/QtQuickApp/">QtQuickApp</a> project, OBS will build it for me.</p>
</div>
</div>
</div>
</div>
<span id="document-packaging-guide/manual"></span><div class="section" id="manual-packaging">
<span id="ref-manual"></span><h3>Manual packaging<a class="headerlink" href="#manual-packaging" title="Permalink to this headline">¶</a></h3>
<p>Create an AppDir manually, then turn it into an AppImage. Start out with the example below, then check the examples on bundling certain applications or type of applications as AppImages from the right-hand side <strong>“Pages”</strong> menu.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#creating-an-appdir-manually" id="id1">Creating an AppDir manually</a></p></li>
<li><p><a class="reference internal" href="#no-hard-coded-paths" id="id2">No hard-coded paths</a></p></li>
<li><p><a class="reference internal" href="#creating-an-appimage-from-the-appdir" id="id3">Creating an AppImage from the AppDir</a></p></li>
<li><p><a class="reference internal" href="#bundling-gtk-libraries" id="id4">Bundling GTK libraries</a></p></li>
</ul>
</div>
<div class="section" id="creating-an-appdir-manually">
<span id="ref-creating-an-appdir-manually"></span><h4><a class="toc-backref" href="#id1">Creating an AppDir manually</a><a class="headerlink" href="#creating-an-appdir-manually" title="Permalink to this headline">¶</a></h4>
<p>In practice, you will probably never do this by hand. So this is mainly to illustrate the concept.</p>
<p>Create an AppDir structure that looks (as a minimum) like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyApp</span><span class="o">.</span><span class="n">AppDir</span><span class="o">/</span>
<span class="n">MyApp</span><span class="o">.</span><span class="n">AppDir</span><span class="o">/</span><span class="n">AppRun</span>
<span class="n">MyApp</span><span class="o">.</span><span class="n">AppDir</span><span class="o">/</span><span class="n">myapp</span><span class="o">.</span><span class="n">desktop</span>
<span class="n">MyApp</span><span class="o">.</span><span class="n">AppDir</span><span class="o">/</span><span class="n">myapp</span><span class="o">.</span><span class="n">png</span>
<span class="n">MyApp</span><span class="o">.</span><span class="n">AppDir</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">myapp</span>
<span class="n">MyApp</span><span class="o">.</span><span class="n">AppDir</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">libfoo</span><span class="o">.</span><span class="n">so</span><span class="o">.</span><span class="mi">0</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">AppRun</span></code> file can be a script or executable. It sets up required environment variables such as <code class="code docutils literal notranslate"><span class="pre">$PATH</span></code> and launches the payload application. You can write your own, but in most cases it is easiest (and most error-proof) to use a precompiled one from this repository.</p>
<p>Of course you can leave out the library if your app does not need one, or if all libraries your app needs are already contained in every base operating system you are targeting.</p>
</div>
<div class="section" id="no-hard-coded-paths">
<span id="ref-no-hard-coded-paths"></span><h4><a class="toc-backref" href="#id2">No hard-coded paths</a><a class="headerlink" href="#no-hard-coded-paths" title="Permalink to this headline">¶</a></h4>
<p>Your binary, myapp, must not contain any hardcoded paths that would prevent it from being relocateable. You can check this by running</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>strings MyApp.AppDir/usr/bin/myapp <span class="p">|</span> grep /usr
</pre></div>
</div>
<p>Should this return something, then you need to modify your app programmatically (e.g., by using relative paths, using <a class="reference external" href="https://github.com/limbahq/binreloc">binreloc</a>, or using <code class="code docutils literal notranslate"><span class="pre">QString</span> <span class="pre">QCoreApplication::applicationDirPath()</span></code>).</p>
<p>If you prefer not to change the source code of your app and/or would not like to recompile your app, you can also patch the binary, for example using the command</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sed -i -e <span class="s1">&#39;s#/usr#././#g&#39;</span> MyApp.AppDir/usr/bin/myapp
</pre></div>
</div>
<p>This usually works as long as the application is not doing a <code class="code docutils literal notranslate"><span class="pre">chdir()</span></code> which would break this workaround, because then <code class="code docutils literal notranslate"><span class="pre">././</span></code> would not be pointing to <code class="code docutils literal notranslate"><span class="pre">$APPDIR/usr</span></code> any more. You can run the following command to see whether the application is doing a <code class="code docutils literal notranslate"><span class="pre">chdir()</span></code> (99% of GUI applications don’t)</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>strace -echdir -f ./AppRun
</pre></div>
</div>
<dl class="simple">
<dt>Also see:</dt><dd><p><a class="reference external" href="https://www.gnu.org/software/gnulib/manual/html_node/Supporting-Relocation.html">https://www.gnu.org/software/gnulib/manual/html_node/Supporting-Relocation.html</a></p>
</dd>
</dl>
<p>It has been a pain for many users of GNU packages for a long time that packages are not relocatable. The relocatable-prog module aims to ease the process of making a GNU program relocatable.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same is true for any helper binaries and/or libraries that your app depends on. You check this and patch it with</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> MyApp.AppDir/usr/
find . -type f -exec sed -i -e <span class="s1">&#39;s#/usr#././#g&#39;</span> <span class="o">{}</span> <span class="se">\;</span>
<span class="nb">cd</span> -
</pre></div>
</div>
<p>which replaces all occurrences of <code class="code docutils literal notranslate"><span class="pre">/usr</span></code> with <code class="code docutils literal notranslate"><span class="pre">././</span></code>, which simply means “here”.</p>
</div>
<p>myapp.desktop should contain (as a minimum):</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Desktop Entry]</span>
<span class="na">Name</span><span class="o">=</span><span class="s">MyApp</span>
<span class="na">Exec</span><span class="o">=</span><span class="s">myapp</span>
<span class="na">Icon</span><span class="o">=</span><span class="s">myapp</span>
<span class="na">Type</span><span class="o">=</span><span class="s">Application</span>
<span class="na">Categories</span><span class="o">=</span><span class="s">Utility;</span>
</pre></div>
</div>
<p>Be sure to pick one of the <a class="reference external" href="https://standards.freedesktop.org/menu-spec/latest/apa.html">Registered Categories</a>, and be sure that your desktop file passes validation by using <code class="code docutils literal notranslate"><span class="pre">desktop-file-validate</span> <span class="pre">your.desktop</span></code>. If you are not deploying an application with a graphical user interface (GUI) but a command line tool (for the terminal), make sure to add <code class="code docutils literal notranslate"><span class="pre">Terminal=true</span></code>.</p>
</div>
<div class="section" id="creating-an-appimage-from-the-appdir">
<h4><a class="toc-backref" href="#id3">Creating an AppImage from the AppDir</a><a class="headerlink" href="#creating-an-appimage-from-the-appdir" title="Permalink to this headline">¶</a></h4>
<p>To create an AppImage, run <code class="code docutils literal notranslate"><span class="pre">appimagetool</span></code> on the AppDir in order to turn it into an AppImage. You can get it from this repository’s <a class="reference external" href="https://github.com/AppImage/AppImageKit/releases">Releases</a> page (it comes as an AppImage itself; yes, we eat our own dogfood).</p>
</div>
<div class="section" id="bundling-gtk-libraries">
<h4><a class="toc-backref" href="#id4">Bundling GTK libraries</a><a class="headerlink" href="#bundling-gtk-libraries" title="Permalink to this headline">¶</a></h4>
<p>The following steps allow bundling the GTK libraries and configuration files in a relocatable way, without the need to patch the files and replace hard-coded paths. The full set of bundling commands, in the form of a bash script, can be found <a class="reference external" href="https://github.com/aferrero2707/appimage-helper-scripts/blob/master/bundle-gtk2.sh">here</a>. They assume the existence of an <code class="code docutils literal notranslate"><span class="pre">APPDIR</span></code> environment variable that points to the root folder of the AppImage bundle.</p>
<div class="section" id="gdk-pixbuf-modules-and-cache-file">
<h5>GDK-Pixbuf modules and cache file<a class="headerlink" href="#gdk-pixbuf-modules-and-cache-file" title="Permalink to this headline">¶</a></h5>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">gdk_pixbuf_moduledir</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>pkg-config --variable<span class="o">=</span>gdk_pixbuf_moduledir gdk-pixbuf-2.0<span class="k">)</span><span class="s2">&quot;</span>
<span class="nv">gdk_pixbuf_cache_file</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>pkg-config --variable<span class="o">=</span>gdk_pixbuf_cache_file gdk-pixbuf-2.0<span class="k">)</span><span class="s2">&quot;</span>
<span class="nv">gdk_pixbuf_libdir_bundle</span><span class="o">=</span><span class="s2">&quot;lib/gdk-pixbuf-2.0&quot;</span>
<span class="nv">gdk_pixbuf_cache_file_bundle</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/</span><span class="si">${</span><span class="nv">gdk_pixbuf_libdir_bundle</span><span class="si">}</span><span class="s2">/loaders.cache&quot;</span>
mkdir -p <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/</span><span class="si">${</span><span class="nv">gdk_pixbuf_libdir_bundle</span><span class="si">}</span><span class="s2">&quot;</span>
cp -a <span class="s2">&quot;</span><span class="nv">$gdk_pixbuf_moduledir</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/</span><span class="si">${</span><span class="nv">gdk_pixbuf_libdir_bundle</span><span class="si">}</span><span class="s2">&quot;</span>
cp -a <span class="s2">&quot;</span><span class="nv">$gdk_pixbuf_cache_file</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/</span><span class="si">${</span><span class="nv">gdk_pixbuf_libdir_bundle</span><span class="si">}</span><span class="s2">&quot;</span>
sed -i -e <span class="s2">&quot;s|</span><span class="si">${</span><span class="nv">gdk_pixbuf_moduledir</span><span class="si">}</span><span class="s2">/||g&quot;</span> <span class="s2">&quot;</span><span class="nv">$gdk_pixbuf_cache_file_bundle</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>The hard-coded paths in the cache file are removed by the <code class="code docutils literal notranslate"><span class="pre">sed</span></code> command. At run time, the <code class="code docutils literal notranslate"><span class="pre">$APPDIR/usr/ib/gdk-pixbuf-2.0/loaders</span></code> folder has to be added to the <code class="code docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> environment variable, so that the bundled GDK-Pixbuf loaders can be correctly found by the linker.</p>
</div>
<div class="section" id="glib-schemas">
<h5>GLib schemas<a class="headerlink" href="#glib-schemas" title="Permalink to this headline">¶</a></h5>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">glib_prefix</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>pkg-config --variable<span class="o">=</span>prefix glib-2.0<span class="k">)</span><span class="s2">&quot;</span>
mkdir -p <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/share/glib-2.0/schemas/&quot;</span>
cp -a <span class="si">${</span><span class="nv">glib_prefix</span><span class="si">}</span>/share/glib-2.0/schemas/* <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/share/glib-2.0/schemas&quot;</span>
<span class="nb">cd</span> <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/share/glib-2.0/schemas/&quot;</span>
glib-compile-schemas .
</pre></div>
</div>
</div>
<div class="section" id="theme-engines">
<h5>Theme engines<a class="headerlink" href="#theme-engines" title="Permalink to this headline">¶</a></h5>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mkdir -p <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/lib/gtk-2.0&quot;</span>
<span class="nv">GTK_LIBDIR</span><span class="o">=</span><span class="k">$(</span>pkg-config --variable<span class="o">=</span>libdir gtk+-2.0<span class="k">)</span>
<span class="nv">GTK_BINARY_VERSION</span><span class="o">=</span><span class="k">$(</span>pkg-config --variable<span class="o">=</span>gtk_binary_version gtk+-2.0<span class="k">)</span>
cp -a <span class="s2">&quot;</span><span class="si">${</span><span class="nv">GTK_LIBDIR</span><span class="si">}</span><span class="s2">/gtk-2.0/</span><span class="si">${</span><span class="nv">GTK_BINARY_VERSION</span><span class="si">}</span><span class="s2">&quot;</span>/* <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/lib/gtk-2.0&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="rsvg-library">
<h5>RSVG library<a class="headerlink" href="#rsvg-library" title="Permalink to this headline">¶</a></h5>
<p>This library is not automatically picked, because it is a dependency of the GDK-Pixbuf loaders and not of the global GTK libraries.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">GDK_PIXBUF_MODULEDIR</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">APPDIR</span><span class="si">}</span><span class="s2">/usr/lib/gdk-pixbuf-2.0/loaders&quot;</span>

mkdir -p <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/lib&quot;</span>
<span class="nv">RSVG_LIBDIR</span><span class="o">=</span><span class="k">$(</span>pkg-config --variable<span class="o">=</span>libdir librsvg-2.0<span class="k">)</span>
<span class="k">if</span> <span class="o">[</span> x<span class="s2">&quot;</span><span class="si">${</span><span class="nv">RSVG_LIBDIR</span><span class="si">}</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;x&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
<span class="nb">export</span> <span class="nv">GDK_PIXBUF_MODULE_FILE</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">APPDIR</span><span class="si">}</span><span class="s2">/usr/lib/gdk-pixbuf-2.0/loaders.cache&quot;</span>
     <span class="nb">echo</span> <span class="s2">&quot;cp -a </span><span class="si">${</span><span class="nv">RSVG_LIBDIR</span><span class="si">}</span><span class="s2">/librsvg*.so* </span><span class="nv">$APPDIR</span><span class="s2">/usr/lib&quot;</span>
     cp -a <span class="s2">&quot;</span><span class="si">${</span><span class="nv">RSVG_LIBDIR</span><span class="si">}</span><span class="s2">&quot;</span>/librsvg*.so* <span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/lib&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
</div>
<div class="section" id="run-time-environment-variables">
<h5>Run-time environment variables<a class="headerlink" href="#run-time-environment-variables" title="Permalink to this headline">¶</a></h5>
<p>The following environment variables need to be set when running the AppImage:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">GDK_PIXBUF_MODULEDIR</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">APPDIR</span><span class="si">}</span><span class="s2">/usr/lib/gdk-pixbuf-2.0/loaders&quot;</span>
<span class="nb">export</span> <span class="nv">GDK_PIXBUF_MODULE_FILE</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">APPDIR</span><span class="si">}</span><span class="s2">/usr/lib/gdk-pixbuf-2.0/loaders.cache&quot;</span>
<span class="nb">export</span> <span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$LD_LIBRARY_PATH</span><span class="s2">:</span><span class="nv">$GDK_PIXBUF_MODULEDIR</span><span class="s2">&quot;</span>
<span class="nb">export</span> <span class="nv">GTK_PATH</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/lib/gtk-2.0&quot;</span>
<span class="nb">export</span> <span class="nv">GTK_IM_MODULE_FILE</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/lib/gtk-2.0:</span><span class="nv">$GTK_PATH</span><span class="s2">&quot;</span>
<span class="nb">export</span> <span class="nv">PANGO_LIBDIR</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$APPDIR</span><span class="s2">/usr/lib&quot;</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-packaging-guide/testing"></span><div class="section" id="testing-your-appimage">
<h3>Testing your AppImage<a class="headerlink" href="#testing-your-appimage" title="Permalink to this headline">¶</a></h3>
<p>Testing your AppImage is a very important step in producing an AppImage. Since AppImage files are supposed to run on a variety of Linux distributions, it is important to test your AppImage on a wide variety of distributions.</p>
<p class="centered">
<strong><strong>Test your AppImage on all base operating systems you are targeting!</strong></strong></p><p>This is an important step which you should not skip. Subtle differences in distributions make this a must. While it is possible in most cases to create AppImages that run on various distributions, this does not come automatically, but requires careful hand-tuning.</p>
<p>To ensure that the AppImage runs on the intended base systems, it should be thoroughly tested on each of them. The following testing procedure is both efficient and effective: Get the previous version of Ubuntu, Fedora, and openSUSE Live CDs and test your AppImage there. Using the three largest distributions increases the chances that your AppImage will run on other distributions as well. Using the previous (current minus one) version ensures that your end users who might not have upgraded to the latest version yet can still run your AppImage.</p>
<p>Using Live CDs has the advantage that unlike installed systems, you always have a system that is in a factory-fresh condition that can be easily reproduced. Most developers just test their software on their main working systems, which tend to be heavily customized through the installation of additional packages. By testing on Live CDs, you can be sure that end users will get the best experience possible.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#using-testappimage" id="id1">Using testappimage</a></p></li>
<li><p><a class="reference internal" href="#using-the-docker-based-appimage-testsuite" id="id2">Using the Docker-based appimage-testsuite</a></p></li>
</ul>
</div>
<div class="section" id="using-testappimage">
<h4><a class="toc-backref" href="#id1">Using testappimage</a><a class="headerlink" href="#using-testappimage" title="Permalink to this headline">¶</a></h4>
<p>You can use ISOs of Live CDs, loop-mount them, chroot into them, and run the AppImage there. This way, you need approximately 700 MB per supported base system (distribution) and can easily upgrade to newer versions by just exchanging one ISO file. The following script automates this for Ubuntu-like (Casper-based) and Fedora-like (Dract-based) Live ISOs:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ wget https://raw.githubusercontent.com/AppImage/AppImageKit/master/testappimage
$ sudo bash testappimage /path/to/elementary-0.2-20110926.iso AppImageAssistant.AppImage
</pre></div>
</div>
</div>
<div class="section" id="using-the-docker-based-appimage-testsuite">
<h4><a class="toc-backref" href="#id2">Using the Docker-based appimage-testsuite</a><a class="headerlink" href="#using-the-docker-based-appimage-testsuite" title="Permalink to this headline">¶</a></h4>
<p>In addition to Live CD ISOs, it is possible to use Docker containers to test an AppImage package on a large variety of Linux distributions. This approach works for virtually any Linux distribution for which a base Docker container is available. For each of the supported distributions, there is a corresponding DockerFile that allows to build a container with a minimal set of dependencies needed to run an AppImage package.</p>
<p>Currently, only type2 AppImages that provide the <code class="docutils literal notranslate"><span class="pre">--appimage-extract</span></code> option are supported.</p>
<p>For example, to test an AppImage package on Ubuntu 18.04, the steps to be followed are:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ git clone https://github.com/aferrero2707/appimage-testsuite.git
$ <span class="nb">cd</span> appimage-testsuite
$ ./run.sh PATH_TO_APPIMAGE/package.AppImage ubuntu-18.04
<span class="c1"># /aitest/aitest.sh</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">run.sh</span></code> script will build the corresponding Docker container, determine the IP address of the host system, and run the container with convenient parameters. The host <code class="docutils literal notranslate"><span class="pre">HOME</span></code> folder is mapped to the <code class="docutils literal notranslate"><span class="pre">/shared</span></code> folder in the running container, and the X server is forwarded to the host system so that graphical applications can be correctly executed.</p>
<p>The following Linux distributions are supported out-of-the-box:</p>
<ul class="simple">
<li><p>Ubuntu 14.04, 16.04 and 18.04</p></li>
<li><p>CentOS 6 and 7</p></li>
<li><p>Fedora 26 and 27</p></li>
<li><p>Debian stable and testing</p></li>
<li><p>Manjaro (Arch Linux derivative)</p></li>
<li><p>Sabayon (Gentoo Linux derivative)</p></li>
</ul>
<p>Other distributions can be added by writing an appropriate Dockerfile.</p>
<p>Users might need to modify the <code class="docutils literal notranslate"><span class="pre">run.sh</span></code> script and change the line used to guess the host IP address:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">IP</span><span class="o">=</span><span class="k">$(</span>ifconfig en0 <span class="p">|</span> grep inet <span class="p">|</span> awk <span class="s1">&#39;$1==&quot;inet&quot; {print $2}&#39;</span><span class="k">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-packaging-guide/distribution"></span><div class="section" id="distributing-appimages">
<span id="ref-distribution"></span><h3>Distributing AppImages<a class="headerlink" href="#distributing-appimages" title="Permalink to this headline">¶</a></h3>
<p>There are several ways to distribute AppImages to users. Most likely, AppImages are distributed from their creator to the users.</p>
<p>The following section contains some details on how AppImages are commonly distributed.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#hosting-appimages" id="id2">Hosting AppImages</a></p></li>
<li><p><a class="reference internal" href="#complying-with-licenses" id="id3">Complying with licenses</a></p></li>
<li><p><a class="reference internal" href="#do-not-put-linux-into-the-appimage-file-name" id="id4">Do not put “Linux” into the Appimage file name</a></p></li>
<li><p><a class="reference internal" href="#do-not-put-appimages-into-other-archives" id="id5">Do not put AppImages into other archives</a></p></li>
<li><p><a class="reference internal" href="#making-your-appimages-discoverable" id="id6">Making your AppImages discoverable</a></p></li>
</ul>
</div>
<div class="section" id="hosting-appimages">
<span id="ref-hosting-appimages"></span><h4><a class="toc-backref" href="#id2">Hosting AppImages</a><a class="headerlink" href="#hosting-appimages" title="Permalink to this headline">¶</a></h4>
<p>Most commonly, AppImage creators host the files on a standard web server. This is the easiest and most accessible way.</p>
<p>We recommend that you put the AppImage for Linux on your project’s download page alongside the dmg for macOS and the exe for Windows, like so:</p>
<a class="reference internal image-reference" href="_images/release-page-screenshot.png"><img alt="Download page overview, showing Windows, MacOS, Linux and Source code downloads" class="align-center" src="_images/release-page-screenshot.png" style="width: 80%;" /></a>
<p>For open source projects, if your project is located on GitHub, we recommend that you publish your AppImage in addition on <a class="reference external" href="https://help.github.com/en/articles/creating-releases/">GitHub Releases</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For <span class="xref std std-ref">AppImageUpdate</span> to work properly, it is required that the web server supports HTTP range requests. Most web hosts support this, as the same technology is used for navigating an MP3 files, for example.</p>
<p>Some hosted services are known not to support range requests right now. These involve:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://gitlab.com">Gitlab releases</a></p></li>
</ul>
</div></blockquote>
<p>If you use such a service and wish to use <span class="xref std std-ref">AppImageUpdate</span> with it, please ask the providers to enable range requests.</p>
</div>
</div>
<div class="section" id="complying-with-licenses">
<span id="ref-complying-with-licenses"></span><h4><a class="toc-backref" href="#id3">Complying with licenses</a><a class="headerlink" href="#complying-with-licenses" title="Permalink to this headline">¶</a></h4>
<p>Even under open source licenses, distributing and/or using code in source or binary form may create certain legal obligations, such as the distribution of the corresponding source code and build instructions for GPL licensed binaries, and displaying copyright statements and disclaimers. As the author of an application which you are distributing as an AppImage, you are responsible to obey all licenses for any third-party dependencies that you include in your AppImage, and ensure that their licenses and source code are made available, where required, together with the release binaries. AppImageKit itself is released under the permissive MIT license.</p>
</div>
<div class="section" id="do-not-put-linux-into-the-appimage-file-name">
<span id="ref-no-linux-in-appimage-filename"></span><h4><a class="toc-backref" href="#id4">Do not put “Linux” into the Appimage file name</a><a class="headerlink" href="#do-not-put-linux-into-the-appimage-file-name" title="Permalink to this headline">¶</a></h4>
<p>Please <strong>DO NOT</strong> put “linux” into the file name of an AppImage. It is abundantly clear that an <code class="code docutils literal notranslate"><span class="pre">.exe</span></code> is for Windows, a <code class="code docutils literal notranslate"><span class="pre">.dmg</span></code> is for the Mac and that <code class="code docutils literal notranslate"><span class="pre">.AppImage</span></code> is for Linux. No need to duplicate.</p>
</div>
<div class="section" id="do-not-put-appimages-into-other-archives">
<span id="ref-no-appimages-in-archives"></span><h4><a class="toc-backref" href="#id5">Do not put AppImages into other archives</a><a class="headerlink" href="#do-not-put-appimages-into-other-archives" title="Permalink to this headline">¶</a></h4>
<p>Please <strong>DO NOT</strong> put an AppImage into another archive like a <code class="code docutils literal notranslate"><span class="pre">.zip</span></code> or <code class="code docutils literal notranslate"><span class="pre">.tar.gz</span></code>.</p>
<p>While it may be tempting to avoid users having to set permission, this breaks desktop integration with the optional <code class="code docutils literal notranslate"><span class="pre">appimaged</span></code> daemon, among other things. Besides, the beauty of the AppImage format is that you never need to unpack anything. Furthermore, packing an AppImage into some form of archive prevents the AppImage from being added to the central catalog of available AppImages at <a class="reference external" href="https://github.com/AppImage/appimage.github.io">https://github.com/AppImage/appimage.github.io</a>.</p>
</div>
<div class="section" id="making-your-appimages-discoverable">
<h4><a class="toc-backref" href="#id6">Making your AppImages discoverable</a><a class="headerlink" href="#making-your-appimages-discoverable" title="Permalink to this headline">¶</a></h4>
<p>Now that you have produced your AppImage, you want users to be able to easily find it. To get users, you need to make your AppImage known to the world.</p>
<div class="section" id="application-website">
<h5>Application website<a class="headerlink" href="#application-website" title="Permalink to this headline">¶</a></h5>
<p>The most obvious place to advertise your AppImage is to prominently featured on your application’s download page.</p>
</div>
<div class="section" id="download-as-an-appimage-banner">
<h5>‘Download as an AppImage’ banner<a class="headerlink" href="#download-as-an-appimage-banner" title="Permalink to this headline">¶</a></h5>
<p>You can use a “Download as an AppImage” banner alongside other similar buttons:</p>
<img alt="Download as an AppImage" src="_images/download-appimage-banner.svg" /><p>Link this banner directly to the latest version of your AppImage, or to a download page containing the link to the latest version of your AppImage.</p>
<p>Banner by <a class="reference external" href="https://github.com/KhushrajRathod/">Khushraj Rathod</a> under the <a class="reference external" href="https://creativecommons.org/share-your-work/public-domain/cc0/">CC0 license</a></p>
</div>
<div class="section" id="social-media">
<h5>Social Media<a class="headerlink" href="#social-media" title="Permalink to this headline">¶</a></h5>
<p>Also be sure to advertise your new AppImage on social media, for example on Twitter, blogs, etc. Be sure to use the <code class="code docutils literal notranslate"><span class="pre">#AppImage</span></code> hashtag for additional discoverability.</p>
</div>
<div class="section" id="appimagehub">
<h5>AppImageHub<a class="headerlink" href="#appimagehub" title="Permalink to this headline">¶</a></h5>
<p>You may want to add your AppImage to <a class="reference external" href="https://appimage.github.io/apps/">AppImageHub</a>, a crowd-sourced directory of available, automatically tested AppImages with data that 3rd party app stores and software centers can use. Given an URL to an AppImage, it inspects the AppImage and puts it into a community-maintained catalog.</p>
<p>App stores and software centers can consume the metadata collected by this project. See <a class="reference external" href="https://github.com/AppImage/AppImageKit/wiki/Ecosystem">AppImage ecosystem</a>.</p>
<p>Projects already using this data include:</p>
<blockquote>
<div><ul class="simple">
<li><p>Nitrux, NX Software Center: <a class="reference external" href="https://github.com/Nitrux/nx-software-center">https://github.com/Nitrux/nx-software-center</a></p></li>
<li><p><a class="reference external" href="https://github.com/simoniz0r/spm">https://github.com/simoniz0r/spm</a></p></li>
<li><p><a class="reference external" href="https://github.com/sillasleal/appcenter">https://github.com/sillasleal/appcenter</a></p></li>
<li><p><a class="reference external" href="https://github.com/lliurex/lliurex-store">https://github.com/lliurex/lliurex-store</a></p></li>
<li><p>Please contact us if you are using this data so that we can list your project here</p></li>
</ul>
</div></blockquote>
<p>To get your AppImage included, create a new file at <a class="reference external" href="https://github.com/AppImage/AppImageHub/new/master/data">https://github.com/AppImage/AppImageHub/new/master/data</a> and send a pull request.</p>
<p>The file should contain one line with a link to the GitHub repository that hosts AppImages on its Releases page.</p>
<p>Alternatively, a link to the AppImage. Nothing else.</p>
<p>Then send a pull request. Travis CI will instantly perform an automated review of the AppImage, and in case it succeeds, you will see a green result in your pull request. If you get a red result, check the log of the Travis CI build, and fix it.</p>
<p>Once an application is added to AppImageHub, it is not updated automatically anymore unless its input file changes. In case you need to get your entry on AppImageHub updated (e.g., you provided new meta information in your latest AppImage release), you need to submit another pull request. At the bottom of your AppImageHub page, you will find a link named “Edit the input for this page” with which you can do this. If the URL has stayed the same, adding or removing a “#” character in a new line will trigger an update. Remember that AppImageHub does not keep track of versions, so it is not necessary to do this just because you released a new version of your application.</p>
<p>As a format, AppImage is designed in a way that does not impose restrictions on the person generating AppImages. Basically you are free to put inside an AppImage whatever you want. For AppImageHub, however, additional rules apply. AppImages submitted to AppImage hub undergo automatic and possibly additional manual review.</p>
<ul class="simple">
<li><p>Must be downloadable from an URL. Our testing system fetches the AppImage using <code class="code docutils literal notranslate"><span class="pre">wget</span></code>. Currently we cannot get AppImages from locations behind authentication and/or cookie-protected locations. For commercial applications we recommend to have a generally downloadable demo/trial version. Please contact us if you would like to add your commercial AppImage to the directory and it is not available for general download</p></li>
<li><p>Must run on the <a class="reference external" href="https://www.ubuntu.com/info/release-end-of-life">oldest still-supported Ubuntu LTS release</a> (16.04 as of 2019, for up to date information see <a class="reference external" href="https://en.wikipedia.org/wiki/Ubuntu#Releases">https://en.wikipedia.org/wiki/Ubuntu#Releases</a>) without the installation of additional packages. Targeting the oldest still-supported LTS is to ensure that the AppImage will run not only on the very latest, but also on older target systems, such as enterprise distributions (not limited to Ubuntu)</p></li>
<li><p>Must execute in our Travis CI based testing environment</p></li>
<li><p>Must pass <a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/master/appdir-lint.sh">appdir-lint.sh</a></p></li>
<li><p>Must have a desktop file that passes <code class="code docutils literal notranslate"><span class="pre">desktop-file-validate</span></code></p></li>
<li><p>Must run without active Internet connection (and at least show some information)</p></li>
<li><p>Should have an <a class="reference external" href="https://people.freedesktop.org/~hughsient/appdata/">AppStream metainfo file</a> in <code class="code docutils literal notranslate"><span class="pre">usr/share/metainfo</span></code>. If it does, must pass <code class="code docutils literal notranslate"><span class="pre">appstreamcli</span></code> validation</p></li>
<li><p>Should show a useful screen rather than some crude dialog box since the main window will be used for the main screenshots. Note that you can provide your own screenshots by using an <a class="reference external" href="https://people.freedesktop.org/~hughsient/appdata/">AppStream metainfo file</a></p></li>
<li><p>Should be available under a constant URL that does not contain the version number. Alternatively, should be available on GitHub Releases or the openSUSE Build Service (you are free to suggest additional serices like these)</p></li>
</ul>
</div>
<div class="section" id="future-catalogs">
<h5>Future catalogs<a class="headerlink" href="#future-catalogs" title="Permalink to this headline">¶</a></h5>
<p>In the future, we may want to use decentralized peer-to-peer databases for the catalog of AppImages.</p>
<p>We are currently investigating technologies such as IPFS and would be happy to win contributors in this area.</p>
</div>
</div>
</div>
<span id="document-packaging-guide/environment-variables"></span><div class="section" id="environment-variables">
<h3>Environment variables<a class="headerlink" href="#environment-variables" title="Permalink to this headline">¶</a></h3>
<p>The AppImage runtimes make some environment variables available that can be used by applications bundled as AppImages
during runtime, e.g., to recognize whether it’s currently run from an AppImage, or to get some path information.</p>
<p>Depending on the type of the AppImage, the runtimes offer different feature sets.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#type-1-appimage-runtime" id="id1">Type 1 AppImage runtime</a></p></li>
<li><p><a class="reference internal" href="#type-2-appimage-runtime" id="id2">Type 2 AppImage runtime</a></p></li>
</ul>
</div>
<div class="section" id="type-1-appimage-runtime">
<h4><a class="toc-backref" href="#id1">Type 1 AppImage runtime</a><a class="headerlink" href="#type-1-appimage-runtime" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Type 1 is the deprecated/outdated AppImage type that is only in legacy support mode. It is not recommended to make
new type 1 AppImages. We strongly recommend you to use <code class="code docutils literal notranslate"><span class="pre">appimagetool</span></code> to make type 2 AppImages.</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable name</p></th>
<th class="head"><p>Contents</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">APPIMAGE</span></code></p></td>
<td><p>(Absolute) path to AppImage file (with symlinks resolved)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">APPDIR</span></code></p></td>
<td><p>Path of mountpoint of the ISO9660 image contained in the AppImage</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">OWD</span></code></p></td>
<td><p>Path to working directory at the time the AppImage is called</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="type-2-appimage-runtime">
<h4><a class="toc-backref" href="#id2">Type 2 AppImage runtime</a><a class="headerlink" href="#type-2-appimage-runtime" title="Permalink to this headline">¶</a></h4>
<p>The type 2 AppImage runtime makes a few environment variables available for use in e.g., <code class="docutils literal notranslate"><span class="pre">AppRun</span></code> scripts:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable name</p></th>
<th class="head"><p>Contents</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">APPIMAGE</span></code></p></td>
<td><p>(Absolute) path to AppImage file (with symlinks resolved)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">APPDIR</span></code></p></td>
<td><p>Path of mountpoint of the SquashFS image contained in the AppImage</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">OWD</span></code></p></td>
<td><p>Path to working directory at the time the AppImage is called</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">ARGV0</span></code></p></td>
<td><p>Name/path used to execute the script. This corresponds to the value you’d normally receive via
the <code class="code docutils literal notranslate"><span class="pre">argv</span></code> argument passed to your <code class="code docutils literal notranslate"><span class="pre">main</span></code> method.
Usually contains the filename or path to the AppImage, relative to the current working
directory.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">APPIMAGE</span></code> and <code class="code docutils literal notranslate"><span class="pre">ARGV0</span></code> have very different use cases.</p>
<p><code class="code docutils literal notranslate"><span class="pre">APPIMAGE</span></code> shall be used every time the full path of the AppImage is needed, e.g., if you need to touch the
AppImage file, for example when you want to update it or read some meta information.</p>
<p><code class="code docutils literal notranslate"><span class="pre">ARGV0</span></code> provides information how the AppImage was called. When you call an AppImage through a symlink for
instance, you can get the path to this symlink through <code class="code docutils literal notranslate"><span class="pre">ARGV0</span></code>, while <code class="code docutils literal notranslate"><span class="pre">APPIMAGE</span></code> would contain the
absolute path to the file behind that symlink.</p>
<p>Scenarios where <code class="code docutils literal notranslate"><span class="pre">ARGV0</span></code> is really useful involve so-called multi-binary AppImages, where the filename
in <code class="code docutils literal notranslate"><span class="pre">ARGV0</span></code> defines which program is called inside the AppImage. This concept is also known from
single-binary tools like <a class="reference external" href="https://en.wikipedia.org/wiki/BusyBox">BusyBox</a>, and can be implemented in a custom
<code class="code docutils literal notranslate"><span class="pre">AppRun</span></code> script (see <a class="reference internal" href="index.html#ref-architecture"><span class="std std-ref">Architecture</span></a> for more information).</p>
</div>
</div>
</div>
</div>
</div>
<span id="document-reference/index"></span><div class="section" id="ref-reference">
<span id="reference"></span><span id="id1"></span><h2>Reference<a class="headerlink" href="#ref-reference" title="Permalink to this headline">¶</a></h2>
<p>The following section contains reference documents like standards, etc.</p>
<div class="toctree-wrapper compound">
<span id="document-reference/architecture"></span><div class="section" id="architecture">
<span id="ref-architecture"></span><h3>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h3>
<p>AppImage follows a very simple architecture, which is explained in this section.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id2">Overview</a></p></li>
</ul>
</div>
<div class="section" id="overview">
<h4><a class="toc-backref" href="#id2">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h4>
<p>An AppImage consists of two parts: a <em>runtime</em> and a <em>file system image</em>. For the current type 2, the file system in use is SquashFS.</p>
<div class="figure align-center" id="id1">
<img alt="_images/architecture-overview.svg" src="_images/architecture-overview.svg" /><p class="caption"><span class="caption-text">AppImage file structure. Copyright © <a class="reference external" href="https://github.com/TheAssassin">&#64;TheAssassin</a> 2019. Licensed under CC-By-SA Intl 4.0.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>What happens when an AppImage is run is that the operating system runs the AppImage as an executable. The runtime, the executable part, tries to mount the file system image using <span class="xref std std-ref">FUSE</span>. If that succeeds, the <a class="reference internal" href="index.html#ref-appdir"><span class="std std-ref">AppDir</span></a> is available in a <span class="xref std std-ref">temporary mountpoint</span>, and can be used like a read-only directory.</p>
<p>The runtime continues by calling the AppDir’s “entrypoint” <span class="xref std std-ref">AppRun</span> using the operating system facilities. There are no checks performed by the runtime, the operating system is simply tasked with the execution of <code class="docutils literal notranslate"><span class="pre">&lt;AppDir</span> <span class="pre">mountpoint&gt;/AppRun</span></code>. This provides a lot of flexibility, as AppRun can be an arbitrary executable, a script with a <a class="reference external" href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>, or even a simple symlink to another executable within the AppDir. The file must be executable.</p>
<p>The contents of an AppDir are completely user-specified, although there are tools that help with packaging. For more information, see the <a class="reference internal" href="index.html#ref-packaging-guide"><span class="std std-ref">packaging guide</span></a>.</p>
</div>
</div>
<span id="document-reference/specification"></span><div class="section" id="appimage-specification">
<span id="ref-spec"></span><span id="ref-specification"></span><span id="ref-appimage-specification"></span><h3>AppImage specification<a class="headerlink" href="#appimage-specification" title="Permalink to this headline">¶</a></h3>
<p>The AppImage project maintains a work-in-progress specification on the AppImage format.</p>
<p>Being designed as a standard with a reference implementation allows users to implement their own tools to build AppImages, and helps maintaining compatibility between different tools and components.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#development" id="id1">Development</a></p></li>
<li><p><a class="reference internal" href="#reference-implementation" id="id2">Reference implementation</a></p></li>
</ul>
</div>
<div class="section" id="development">
<h4><a class="toc-backref" href="#id1">Development</a><a class="headerlink" href="#development" title="Permalink to this headline">¶</a></h4>
<p>The specification’s repository contains a description of the current <strong>type 2</strong> format. You can find the
<a class="reference external" href="https://github.com/AppImage/AppImageSpec/blob/master/draft.md">full text</a>
in the <a class="reference external" href="https://github.com/AppImage/AppImageSpec/">GitHub repository</a>.</p>
<p>The documentation receives updates regularly, e.g., to fix bugs or document new features. For type 2, a decision was made to not release specific versions but work with continuous releases. This implies there might be some AppImages that lack newer features because they’re using an older runtime, etc. Backwards compatibility is maintained by the team in the reference implementation.</p>
<p>Please feel free to file <a class="reference external" href="https://github.com/AppImage/AppImageSpec/issues">issues on GitHub</a> if you encounter bugs or have ideas for additional features. Also, improvements on wording etc. are highly appreciated.</p>
</div>
<div class="section" id="reference-implementation">
<h4><a class="toc-backref" href="#id2">Reference implementation</a><a class="headerlink" href="#reference-implementation" title="Permalink to this headline">¶</a></h4>
<p>The project maintains a reference implementation of the standard which is called <a class="reference internal" href="index.html#ref-appimagekit"><span class="std std-ref">AppImageKit</span></a>.</p>
</div>
</div>
<span id="document-reference/best-practices"></span><div class="section" id="best-practices">
<h3>Best practices<a class="headerlink" href="#best-practices" title="Permalink to this headline">¶</a></h3>
<p>This section contains some best practices and recommendations how to generally design and write software so that it can be easily put into AppImages.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#general-recommendations" id="id1">General Recommendations</a></p>
<ul>
<li><p><a class="reference internal" href="#binaries-must-not-use-compiled-in-absolute-paths" id="id2">Binaries must not use compiled-in absolute paths</a></p></li>
<li><p><a class="reference internal" href="#binaries-compiled-on-old-enough-base-system" id="id3">Binaries compiled on old enough base system</a></p></li>
<li><p><a class="reference internal" href="#libstdc-so-6" id="id4">libstdc++.so.6</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-recommendations">
<h4><a class="toc-backref" href="#id1">General Recommendations</a><a class="headerlink" href="#general-recommendations" title="Permalink to this headline">¶</a></h4>
<p>It is crucial to understand that AppImage is merely a format for distributing applications. In this regard, AppImage is like a <code class="code docutils literal notranslate"><span class="pre">.zip</span></code> file or an <code class="code docutils literal notranslate"><span class="pre">.iso</span></code> file. It does not define how to compile applications. It it is also not a build system.</p>
<p>It is crucial to put binaries inside AppImages that are compatible with a variety of target systems. What goes into the AppImage is called the “payload”, or the “ingredients”. Producing the payload requires some thought, as you want your AppImage to run on as many targets systems as possible.</p>
<p>For an AppImage to run on most systems, the following conditions need to be met:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#ref-binaries-no-abs-paths"><span class="std std-ref">Binaries must not use compiled-in absolute paths</span></a> (and if they do, they need to be binary-patched)</p></li>
<li><p>The AppImage needs to include all libraries and other dependencies that are not part of all of the base systems that the AppImage is intended to run on.</p></li>
<li><p>The binaries contained in the AppImage need to be compiled on a system not newer than the oldest base system that the AppImage is intended to run on.</p></li>
<li><p>The AppImage should actually be tested on the base systems that it is intended to run on.</p></li>
</ol>
<div class="section" id="binaries-must-not-use-compiled-in-absolute-paths">
<span id="ref-binaries-no-abs-paths"></span><h5><a class="toc-backref" href="#id2">Binaries must not use compiled-in absolute paths</a><a class="headerlink" href="#binaries-must-not-use-compiled-in-absolute-paths" title="Permalink to this headline">¶</a></h5>
<p>Since an AppImage is mounted at a different location in the filesystem every time it is run, it is crucial not to use compiled in absolute paths. For example, if the application accesses a resource such as an image, it should do so from a location relative to the main executable. Unfortunately, many applications have absolute paths compiled in (<code class="code docutils literal notranslate"><span class="pre">$PREFIX</span></code>, most commonly <code class="code docutils literal notranslate"><span class="pre">/usr</span></code>) at compile time.</p>
<div class="section" id="open-source-applications">
<span id="ref-open-source-applications"></span><h6>Open source applications<a class="headerlink" href="#open-source-applications" title="Permalink to this headline">¶</a></h6>
<p>Wherever possible you should change the Source Code of the application in order not to use absolute paths. There are several ways to do this. The canonical way on Linux is to resolve <code class="docutils literal notranslate"><span class="pre">proc/self/exe</span></code> to get the path to the main executable and construct a relative path from there. As a result, it should work both in normal installations and in relocatable installations such as AppImages.</p>
<p>There are libraries which make this easier, for example <a class="reference external" href="https://github.com/limbahq/binreloc">BinReloc</a>. Also see <a class="reference external" href="https://github.com/drbenmorgan/Resourceful">Resourceful</a>, a project to study of cross-platform techniques for building applications and libraries that use resource files (e.g. icons, configuration, data).</p>
<p>Some application frameworks such as Qt have this functionality built-in, for example in <code class="code docutils literal notranslate"><span class="pre">QString</span> <span class="pre">QCoreApplication::applicationDirPath()</span></code> (<a class="reference external" href="https://doc.qt.io/qt-5/qcoreapplication.html#applicationDirPath">see documentation</a>), and construct a <em>relative</em> path to <code class="code docutils literal notranslate"><span class="pre">../share/kaidan/images/</span></code> from there.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>For an example, see: <a class="reference external" href="https://github.com/KaidanIM/Kaidan/commit/da38011b55a1aa5d17764647ecd699deb4be437f">https://github.com/KaidanIM/Kaidan/commit/da38011b55a1aa5d17764647ecd699deb4be437f</a></p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="code docutils literal notranslate"><span class="pre">QStandardPaths::standardLocations(QStandardPaths::AppDataLocation)</span></code> <strong>does not work reliably.</strong></p>
<p>According to the <a class="reference external" href="https://doc.qt.io/qt-5/qstandardpaths.html">Qt documentation</a>, this resolves to <code class="code docutils literal notranslate"><span class="pre">~/.local/share/&lt;APPNAME&gt;</span></code>, <code class="code docutils literal notranslate"><span class="pre">/usr/local/share/&lt;APPNAME&gt;</span></code>, <code class="code docutils literal notranslate"><span class="pre">/usr/share/&lt;APPNAME&gt;</span></code>, but clearly <code class="code docutils literal notranslate"><span class="pre">/usr</span></code> is not where these things are located in an AppImage.</p>
</div>
</div>
<div class="section" id="closed-source-applications-with-compiled-in-absolute-paths">
<span id="ref-closed-source-apps-abs-paths"></span><h6>Closed source applications with compiled-in absolute paths<a class="headerlink" href="#closed-source-applications-with-compiled-in-absolute-paths" title="Permalink to this headline">¶</a></h6>
<p>In case it is not possible to change the source code of the application, for example because it is a closed source application, you could binary patch the executable.</p>
<p>The trick is to search for <code class="code docutils literal notranslate"><span class="pre">/usr</span></code> in the binary and replace it by the same length string <code class="code docutils literal notranslate"><span class="pre">././</span></code> which means “here”. This can be done by using the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">find</span> <span class="n">usr</span><span class="o">/</span> <span class="o">-</span><span class="nb">type</span> <span class="n">f</span> <span class="o">-</span><span class="n">executable</span> <span class="o">-</span><span class="n">exec</span> <span class="n">sed</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span><span class="n">e</span> <span class="s2">&quot;s|/usr|././|g&quot;</span> <span class="p">{}</span> \<span class="p">;</span>
</pre></div>
</div>
<p>This command is also available as part of the bash function collection at <a class="reference external" href="https://github.com/AppImage/pkg2appimage/blob/9249a99e653272416c8ee8f42cecdde12573ba3e/functions.sh#L79">AppImage/pkg2appimage/functions.sh#L79</a>. For the binary-patched application to work, you need to change to the <code class="code docutils literal notranslate"><span class="pre">usr/</span></code> directory inside the application directory before you launch the application.</p>
</div>
</div>
<div class="section" id="binaries-compiled-on-old-enough-base-system">
<span id="ref-binaries-compiled-on-old-system"></span><h5><a class="toc-backref" href="#id3">Binaries compiled on old enough base system</a><a class="headerlink" href="#binaries-compiled-on-old-enough-base-system" title="Permalink to this headline">¶</a></h5>
<p>The ingredients used in your AppImage should not be built on a more recent base system than the oldest base system your AppImage is intended to run on.</p>
<p>Some core libraries, such as glibc, tend to break compatibility with older base systems quite frequently, which means that binaries will run on newer, but not on older base systems than the one the binaries were compiled on.</p>
<p>If you run into errors like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>failed to initialize: /lib/tls/i686/cmov/libc.so.6: version `GLIBC_2.11&#39; not found
</pre></div>
</div>
<p>then the binary is compiled on a newer system than the one you are trying to run it on. You should use a binary that has been compiled on an older system. Unfortunately, the complication is that distributions usually compile the latest versions of applications only on the latest systems, which means that you will have a hard time finding binaries of bleeding-edge software that runs on older systems. A way around this is to compile dependencies yourself on a not too recent base system, and/or to use <a class="reference external" href="https://github.com/AppImage/AppImageKit/tree/stable/v1.0/LibcWrapGenerator">LibcWrapGenerator</a> or <a class="reference external" href="https://github.com/wheybags/glibc_version_header">glibc_version_header</a> or <a class="reference external" href="https://github.com/sulix/bingcc">bingcc</a>.</p>
<p>When producing AppImages for the Subsurface project, I have had very good results by using <strong>CentOS 6</strong>. This distribution is not too recent (current major CentOS version minus 1) while there are still the most recent Qt and modern compilers for it in the <a class="reference external" href="https://fedoraproject.org/wiki/EPEL">EPEL</a> and <a class="reference external" href="http://people.centos.org/tru/devtools-2/">devtools-2</a> (the community equivalent of the Red Hat Developer Toolset 2) repositories. When using it for compilation, I found the resulting binaries to run on a wide variety of systems, including <strong>debian oldstable</strong> (wheezy).</p>
<p>Be sure to check <a class="reference external" href="https://github.com/AppImage/pkg2appimage">https://github.com/AppImage/pkg2appimage</a>, this is how I build and host my AppImages and the build systems to produce them in the cloud using travis-ci, docker, docker-hub, and bintray. Especially check the recipes for Subsurface and Scribus.</p>
<p>See <a class="reference external" href="https://github.com/AppImage/AppImageKit/wiki/Docker-Hub-Travis-CI-Workflow">https://github.com/AppImage/AppImageKit/wiki/Docker-Hub-Travis-CI-Workflow</a> for a description on how to set up a workflow involving your GitHub repository, Docker Hub, and Travis CI for a fully automated continuous build workflow.</p>
<p>You could also consider to link some exotic libraries statically. Yes, even Debian does that:
<a class="reference external" href="https://lintian.debian.org/tags/embedded-library.html">https://lintian.debian.org/tags/embedded-library.html</a></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>This concept is also described in <a class="reference internal" href="index.html#build-on-old-systems"><span class="std std-ref">Build on old systems, run on newer systems</span></a>.</p>
</div>
</div>
<div class="section" id="libstdc-so-6">
<span id="ref-libstdc-so-6"></span><h5><a class="toc-backref" href="#id4">libstdc++.so.6</a><a class="headerlink" href="#libstdc-so-6" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>As a general rule of thumb, please use no libstdc++.so.6 newer than the one that comes with the oldest distribution that you still want to support, i.e., the oldest still-supported LTS version</strong> (at the time of this writing, Ubuntu 14.04).</p>
</div>
</div>
</div>
</div>
<span id="document-reference/appdir"></span><span class="target" id="ref-appdir-specification"></span><div class="section" id="appdir-specification">
<span id="ref-appdir"></span><h3>AppDir specification<a class="headerlink" href="#appdir-specification" title="Permalink to this headline">¶</a></h3>
<p>This page describes the <em>AppDir</em> format. AppDirs are the “source” of AppImages. When building an AppImage, a file system image is built from such a directory, to which a runtime is prepended.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#history" id="id1">History</a></p></li>
<li><p><a class="reference internal" href="#general-description" id="id2">General description</a></p></li>
<li><p><a class="reference internal" href="#conventions" id="id3">Conventions</a></p></li>
</ul>
</div>
<div class="section" id="history">
<h4><a class="toc-backref" href="#id1">History</a><a class="headerlink" href="#history" title="Permalink to this headline">¶</a></h4>
<p>The AppDir format has first been described by <a class="reference external" href="http://rox.sourceforge.net/desktop/AppDirs.html">ROX Filer</a>, and has since been extended by the AppImage project to suit their needs.</p>
</div>
<div class="section" id="general-description">
<h4><a class="toc-backref" href="#id2">General description</a><a class="headerlink" href="#general-description" title="Permalink to this headline">¶</a></h4>
<p>As the name intends, AppDirs are normal directories with some special contents. The AppDir format is coming from ROX Filer  <a class="reference external" href="http://rox.sourceforge.net/desktop/AppDirs.html">http://rox.sourceforge.net/desktop/AppDirs.html</a>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AppRun</span></code></dt><dd><p>A file (executable, script, etc.) or symlink, serving as the “entry point” for a specific application. It is located in the root directory that makes up an AppDir, so it can be used to calculate paths relative to the (later mounted) AppDir.</p>
</dd>
</dl>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">.DirIcon</span></code></dt><dd><p>PNG icon located in the root directory. Can be used by e.g., thumbnailers, to display application icons rather than a generic filetype symbol. Should be in one of the standard image sizes, e.g., 128x128 or 256x256 pixels.</p>
</dd>
</dl>
<p>These two entries have been re-used from <a class="reference external" href="http://rox.sourceforge.net/desktop/AppDirs.html">ROX Filer</a>’s specification. <a class="reference external" href="http://rox.sourceforge.net/desktop/AppDirs.html">ROX Filer</a> actually specifies additional (but optional) entries, however, AppImage doesn’t use these. Instead, the following ones have been introduced:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">myapp.desktop</span></code></dt><dd><p>A desktop file located in the root directory, describing the payload application. As AppImage is following the principle <a class="reference internal" href="index.html#one-app-one-file-principle"><span class="std std-ref">one app = one file</span></a>, one desktop file is enough to describe the entire AppImage. There <strong>MUST NOT</strong> be more than one desktop file in the root directory. The name of the file doesn’t matter, as long as it carries the <code class="docutils literal notranslate"><span class="pre">.desktop</span></code> extension. Can be a symlink to subdirectories such as <code class="docutils literal notranslate"><span class="pre">usr/share/applications/...</span></code></p>
</dd>
</dl>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">myapp.&lt;icon</span> <span class="pre">ext&gt;</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">myapp.png</span></code>, <code class="docutils literal notranslate"><span class="pre">myapp.svg</span></code>)</dt><dd><p>Application’s icon in the best available quality, ideally a vector graphic. Can be a symlink to subdirectories such as <code class="docutils literal notranslate"><span class="pre">usr/share/icons/hicolor/...</span></code>. In most cases, <span class="xref std std-ref">ref-diricon</span> is a symlink to this file. The filename must be equal to what is set in the <code class="docutils literal notranslate"><span class="pre">Icon=</span></code> entry in the desktop file. It is recommended by AppImage and also the XDG icon specifications to use a lower-case filename which is equal to the desktop file’s name.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Icon=</span></code> entry <strong>SHOULD NOT</strong> contain the file extension, the actual file’s filename however <strong>SHOULD</strong> carry the extension.</p>
</div>
</dd>
</dl>
<p>These four types of entries <strong>MUST</strong> be contained in the AppDir to conform to this specification.</p>
</div>
<div class="section" id="conventions">
<h4><a class="toc-backref" href="#id3">Conventions</a><a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h4>
<p>In contrary to the rules in the previous section, the ones introduced in this section are no basic requirement. However, this is the recommended structure to put applications into AppDirs. It’s picking up ideas from well-known, widely spread Linux standards such as the <a class="reference external" href="https://wiki.linuxfoundation.org/lsb/fhs">Filesystem Hierarchy Standard</a> (part of the <a class="reference external" href="https://wiki.linuxfoundation.org/lsb/start">Linux Standards Base</a>).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>A very good summary of the FHS can be found on <a class="reference external" href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">Wikipedia</a>.</p>
</div>
<div class="section" id="usr-subdirectory">
<h5><code class="docutils literal notranslate"><span class="pre">usr</span></code> subdirectory<a class="headerlink" href="#usr-subdirectory" title="Permalink to this headline">¶</a></h5>
<p>Analog to the FHS, most AppDirs, especially the ones created by the official tools such as <a class="reference internal" href="index.html#ref-linuxdeploy"><span class="std std-ref">linuxdeploy</span></a>, contain a <code class="docutils literal notranslate"><span class="pre">usr</span></code> directory.</p>
<p><code class="docutils literal notranslate"><span class="pre">usr</span></code> originally abbreviated <em>unix system resources</em>. According to the FHS, it contains shared, read-only data, which perfectly suits AppImage’s needs, as AppImages are read-only, too.</p>
<p>The directory contains applications, (shared) libraries, desktop files, icons etc., in separate directories. Only a few of them are useful for AppDirs:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">bin</span></code></dt><dd><p>Executables that can be called by a user.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lib</span></code></dt><dd><p>(Shared) libraries used by applications in <code class="docutils literal notranslate"><span class="pre">bin</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">share</span></code></dt><dd><p>Architecture-independent (shared) data. Inside this directory, some special directories are commonly placed:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">applications</span></code></dt><dd><p>Contains desktop files for applications in <code class="docutils literal notranslate"><span class="pre">bin</span></code>. Normally, there’s just one desktop file in this directory, which is symlinked in the root directory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">icons</span></code></dt><dd><p>Directory containing so-called <a class="reference external" href="https://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html">icon themes</a>. Contains at least one, but often a set of icons for the main application. The icons are referred to by the root desktop file, which means the <a class="reference internal" href="#root-icon"><span class="std std-ref">same constraints</span></a> apply.
Example path: <code class="docutils literal notranslate"><span class="pre">&lt;root&gt;/usr/share/icons/&lt;theme&gt;/&lt;resolution&gt;/apps/myapp.&lt;ext&gt;</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">&lt;root&gt;/usr/share/icons/hicolor/256x256/apps/myapp.png</span></code>
Icon themes placed in this directory are copied to the system during so-called <a class="reference internal" href="index.html#ref-desktop-integration"><span class="std std-ref">desktop integration</span></a>.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="summary">
<h5>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h5>
<p>The modern packaging tools such as <a class="reference internal" href="index.html#ref-linuxdeploy"><span class="std std-ref">linuxdeploy</span></a> create these directories by default to standardize and harmonize AppDir creation. If you intend to <a class="reference internal" href="index.html#ref-manual"><span class="std std-ref">create AppDirs manually</span></a>, you are recommended to follow these recommendations.</p>
</div>
</div>
</div>
<span id="document-reference/desktop-integration"></span><div class="section" id="desktop-integration">
<h3>Desktop integration<a class="headerlink" href="#desktop-integration" title="Permalink to this headline">¶</a></h3>
<p>This section discusses how we integrate AppImages into the Linux desktops, what technologies are involved and what customizations and additions we implemented to adapt them to work for AppImages.</p>
<div class="contents local topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#desktop-files" id="id1">Desktop files</a></p>
<ul>
<li><p><a class="reference internal" href="#custom-keys-introduced-for-appimage-purposes" id="id2">Custom keys introduced for AppImage purposes</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="desktop-files">
<h4><a class="toc-backref" href="#id1">Desktop files</a><a class="headerlink" href="#desktop-files" title="Permalink to this headline">¶</a></h4>
<p>A central component of the Linux desktop, so-called <em>desktop entries</em> (or, colloquially, <em>desktop files</em>) are also relevant for AppImage desktop integration. Every AppImage ships with such a file in its <a class="reference internal" href="index.html#ref-appdir"><span class="std std-ref">AppDir</span></a>.</p>
<p>The <a class="reference external" href="https://www.freedesktop.org/">FreeDesktop</a> project maintains the so-called <a class="reference external" href="https://specifications.freedesktop.org/desktop-entry-spec/latest/">Desktop Entry Specification</a>. Desktop Entry files are <a class="reference external" href="https://en.wikipedia.org/wiki/INI_file">INI</a>-style text documents containing key-value pairs, one per line. The file is structured in multiple sections, most notably the <code class="code docutils literal notranslate"><span class="pre">[Desktop</span> <span class="pre">Entry]</span></code>, where the main information goes into. There’s a set of mandatory and optional keys to be set in these documents, and there may be additional sections.</p>
<div class="section" id="custom-keys-introduced-for-appimage-purposes">
<h5><a class="toc-backref" href="#id2">Custom keys introduced for AppImage purposes</a><a class="headerlink" href="#custom-keys-introduced-for-appimage-purposes" title="Permalink to this headline">¶</a></h5>
<p>Aside from the standardized mandatory and optional keys, there may be additional, proprietary keys. They’re usually prepended with <code class="code docutils literal notranslate"><span class="pre">X-</span></code> to differentiate between standard and custom keys.</p>
<p>The AppImage project defined a few custom keys with special meaning that provide information to enhance our desktop integration algorithm.</p>
<dl>
<dt>X-AppImage-Name</dt><dd><p>Name of the application. Used to relate two AppImages of the same application but different versions.</p>
<p><strong>Examples:</strong> <code class="code docutils literal notranslate"><span class="pre">Krita</span></code>, <code class="code docutils literal notranslate"><span class="pre">Kdenlive</span></code>, <code class="code docutils literal notranslate"><span class="pre">Ultimaker</span> <span class="pre">Cura</span></code></p>
</dd>
<dt>X-AppImage-Version</dt><dd><p>Version of the application bundled in the AppImage.</p>
<p><strong>Examples:</strong> <code class="code docutils literal notranslate"><span class="pre">1.0.0-beta-2</span></code>, <code class="code docutils literal notranslate"><span class="pre">2019.1.1</span></code></p>
</dd>
<dt>X-AppImage-Arch</dt><dd><p>Architecture of the AppImage.</p>
<p><strong>Examples:</strong> <code class="code docutils literal notranslate"><span class="pre">x86_64</span></code>, <code class="code docutils literal notranslate"><span class="pre">i386</span></code></p>
</dd>
</dl>
<p><span class="xref std std-ref">appimagetool</span> and <span class="xref std std-ref">libappimage</span> currently make use mostly of <code class="code docutils literal notranslate"><span class="pre">X-AppImage-Version</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The following discussions in issue trackers contain some background information:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://github.com/AppImage/AppImageKit/issues/59">AppImageKit#59</a></p></li>
<li><p><a class="reference external" href="https://github.com/AppImage/AppImageKit/issues/662">AppImageKit#662</a></p></li>
</ul>
</div></blockquote>
</div>
</div>
</div>
</div>
</div>
</div>
<span id="document-contact"></span><div class="section" id="contact">
<span id="ref-contact"></span><h2>Contact<a class="headerlink" href="#contact" title="Permalink to this headline">¶</a></h2>
<p>The AppImage project documentation is brought to you by <a class="reference external" href="https://github.com/AppImage">the AppImage team</a>. The source code is available <a class="reference external" href="https://github.com/AppImage/docs.appimage.org">on GitHub</a>.</p>
<p>This page outlines how you can contact the team behind AppImage, e.g., to get additional support or have questions answered.</p>
<div class="section" id="irc">
<h3>IRC<a class="headerlink" href="#irc" title="Permalink to this headline">¶</a></h3>
<p>If you have further questions, please feel free to contact the AppImage team. The easiest and fastest way is to join our <a class="reference external" href="irc://chat.freenode.net/appimage">IRC channel #appimage</a> on <a class="reference external" href="https://freenode.net">Freenode</a> (<a class="reference external" href="https://webchat.freenode.net/?channels=appimage">webchat</a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please beware that it might take a few minutes/hours until someone will check the chat and might be able to help you, so don’t give up too quickly, and leave e.g., the tab open in the background if you can. You can also try at other times again. Please read <a class="reference external" href="https://workaround.org/getting-help-on-irc/">this article</a> before joining the IRC chat if you are new to IRC.</p>
</div>
</div>
<div class="section" id="forum">
<h3>Forum<a class="headerlink" href="#forum" title="Permalink to this headline">¶</a></h3>
<p>A slower but more sustainable way is to use the <a class="reference external" href="https://discourse.appimage.org">Discourse forum</a>. You can log in using your existing Google or GitHub account, or alternatively register a local account with your email address.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018, The AppImage project
      <span class="commit">
        
        Revision <code>875b200</code>.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>